<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcul de l'impédance de terre </title>

    <style>

       body {
            
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #dddddd; /* Set background color to light gray */
            overflow: hidden; /* Prevent scrolling */
        } 
 
        .container {
 

            border: 0px solid #ffffff; /* Set background color to light gray */
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling */
            background-color: #dddddd; /* Set background color to light gray */
            
        }

        #sceneContainer {
            flex: 1; /* Take the remaining space */
            width: 83vw;
            height: 91.5vh;
            background-color: #ffffff; /* Set background color to light gray */
            overflow: hidden; /* Ensure no overflow */
            float: right;
            display: flex; /* Flexbox to center content */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            border: 1px solid #ffffff;
            border-radius:10px;
        }

        #item-list {
            list-style-type: none;
            padding: 10px;
            margin: 5px;
            margin-left: 10px; /* Ajouter une marge à gauche */
            width: 16%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 350px; /* Maximum height of the container */
            overflow: auto; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            
        }



        #label-list {
        margin-top: 10px; /* Espace entre item-list et label-list */
        bottom: 0;
        left: 5px;
        margin-top: 5px; /* Add some margin at the top for spacing */
        margin-left: 10px; /* Ajouter une marge à gauche */

        width: 16%;
        padding: 10px;   
        max-height: 500px; /* Maximum height of the container */
        overflow: auto; /* Enable vertical scroll if content overflows */
        background-color: #dddddd; /* Set background color to light gray */
        border: 1px solid #ffffff;
        border-radius:10px;
        }



     

        .select_field {

        background-color: cornsilk;
        color:blue;
        width:250px;
        font-size:14px;
        border: 1px solid #ccc; /* Thin border */

        }

        #button-container {
                    list-style-type: none;
                    padding: 10px;
                    margin: 5px;
                    margin-left: 10px; /* Ajouter une marge à gauche */
                    width: auto;
                    margin-top: 5px; /* Add some margin at the top for spacing */
                    max-height: 50px; /* Maximum height of the container */
                    overflow: auto; /* Enable vertical scroll if content overflows */
                    background-color: #dddddd; /* Set background color to light gray */
                    border: 1px solid #ffffff;
                    border-radius:10px;
                    
                }

        #buttons {
            
            margin: 0px;
            
            position:relative
            
           
        }


        .item {
        background-color: #9797978e;
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 15px;
        cursor: pointer;
        text-align: center;

        }

        .item:hover {
            background-color: rgba(213, 216, 47,0.3); /* Semi-transparent yellow overlay */
        }


    /* Style the labels */
    .label-list {
    list-style-type: none;
    padding: 0;
    margin: 5px;
    color: white;

    
    }

    
    .label {
            color: red; /* Change to red for visibility */
            font-size: 40px; /* Increase size for visibility */
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.7); /* Light background */
            padding: 5px; /* Increase padding */
            border-radius: 3px;
        }


    

    .label-list select {
    list-style-type: none;
    padding: 0;
    margin: 5px;
    color: white
    }

    #data-container {

        padding: 10px;
        margin: 5px;
        margin-left: 10px; /* Ajouter une marge à gauche */
        width: 14%;
        margin-top: 5px; /* Add some margin at the top for spacing */
        max-height: 100px; /* Maximum height of the container */
        overflow: auto; /* Enable vertical scroll if content overflows */
        background-color: #dddddd; /* Set background color to light gray */
        border: 1px solid #ffffff;
        border-radius:10px;
            
    }

    .label_input_field {
        font-size:16px;
    }
       
    
    .selected {

        background-color: #d5d82f;
    }

    .general-data-input {
        width:200px;
        height:20px;
        padding:0px;
        font-Size: 14px;
        color:blue;
        border:1px solid #dddddd;
        background-Color:cornsilk;
    }

    .custom-button {
            background-size: cover;
            background-position: center;
            width: 38px;
            height: 38px;
            border: 1px solid #000000;
            cursor: pointer;
    }

    .custom-button-1 {
            background-image: url("photos/nouveau_fichier.jpg");

        }

    .custom-button-2 {
            background-image: url("photos/open_file_arf.jpg");

        }       

    .custom-button-3 {
            background-image: url("photos/save.jpg");

        }
    


    .custom-button-4 {
            background-image: url("photos/save_as.jpg");

        }

         .custom-button-5 {
            background-image: url("photos/print_definitions.jpg");

        }

        .custom-button-6 {
            background-image: url("photos/lines.jpg");

        }

        .custom-button-27 {
            background-image: url("photos/arc.jpg");

        }



        .custom-button-8 {
            background-image: url("photos/delete.jpg");

        }

        .custom-button-9 {
            background-image: url("photos/run_t.jpg");

        }

        .custom-button-10 {
            background-image: url("photos/cut.jpg");

        }


        .custom-button-12 {
            background-image: url("photos/isometric_view_2.jpg");
  
        }

        .custom-button-13 {
            background-image: url("photos/top_2.jpg");

        }

        .custom-button-14 {
            background-image: url("photos/front_2.jpg");

        }

        .custom-button-15 {
            background-image: url("photos/back_2.jpg");

        }

        .custom-button-16 {
            background-image: url("photos/left_2.jpg");

        }

        .custom-button-17 {
            background-image: url("photos/right_2.jpg");

        }

        .custom-button-18 {
            background-image: url("photos/selection.jpg");

        }

        .custom-button-19 {
            background-image: url("photos/zoom_in.jpg");

        }

        .custom-button-20 {
            background-image: url("photos/zoom_out.jpg");

        }

        .custom-button-21 {
            background-image: url("photos/run-2.jpg");

        }

        .custom-button-21.disabled {
            background-image: url("photos/run_disable.jpg");

        }

        .custom-button-22 {
            background-image: url("photos/run-3.jpg");
   
        }

        .custom-button-23 {
            background-image: url("photos/drag_xy.jpg");

        } 

        .custom-button-24 {
            background-image: url("photos/settings.jpg");

        } 

        .custom-button-25 {
            background-image: url("photos/form.jpg");

        }

        .custom-button-26 {
            background-image: url("photos/results.jpg");

            
        }
        

        .custom-button-26.enabled {
            background-image: url("photos/results_p.jpg");

            
        }

        .custom-button-26.disabled {
            background-image: url("photos/results_n.jpg");

            
        }

        .custom-button-28 {
            background-image: url("photos/maillage.jpg");
            
        }

        .custom-button-29 {
            background-image: url("photos/piquet.jpg");
            
        }

        .custom-button-30 {
            background-image: url("photos/previous.jpg");
  
        }

        .custom-button-30.disabled {
            background-image: url("photos/previous_disabled.jpg");
  
        }

        .custom-button-30.enabled {
            background-image: url("photos/previous.jpg");
  
        }

        .custom-button-31 {
            background-image: url("photos/next.jpg");

        }

        .custom-button-31.disabled {
            background-image: url("photos/next_disabled.jpg");

        }

        .custom-button-31.enabled {
            background-image: url("photos/next.jpg");

        }



        .popup_settings {
            position: fixed;
            top: 60px;
            right: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 400px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;

            
        }

        .popup_form {
            position: fixed;
            top: 60px;
            left: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 500px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;

            
        }

        .popup_cercle {
            position: fixed;
            top: 60px;
            left: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 500px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;
            
        }

        .popup_maillage {
            position: fixed;
            top: 60px;
            left: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 500;
            width: 600px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;
            
        }

        /* Styles for the title */
        .popup-title {
            margin: -20px -20px 20px;
            padding: 10px 20px;
            background-color:#000000;
            color: white;
            font-size: 15px;
            text-align: left;

        }

        .overlay {
                position: fixed;
                top: 5%;
                left: 0;
                width: 0%;
                height: 0%;
                background-color: rgba(255, 255, 255,); /* Fully transparent */
                display: none;
                z-index: 999;
        }

        .color-picker-container {
            display: flex;
            justify-content: space-between; /* Pushes the label to the left and the input to the right */
            align-items: center; /* Vertically aligns both the label and the input */
            width: 100%; /* Ensure the container takes the full width of its parent */
        }

        .color-picker-container label {
            margin-right: 10px; /* Optional: Add some space between the label and input */
        }

        #data-container {

            padding: 10px;
            margin: 5px;
            margin-left: 10px; /* Ajouter une marge à gauche */
            width: 16%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 100px; /* Maximum height of the container */
            overflow: auto; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;


        }




        #data-container-settings {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: space-between; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
               
            
        }

        #data-container-cercle {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: space-between; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
               
            
        }

        #data-container-maillage {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: space-between; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
               
            
        }

        #data-container-settings-button {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: center; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
        

        }

        .general-data-input {

            width:250px;
            height:20px;
            padding:0px;
            font-Size: 14px;
            color:blue;
            border:1px solid #dddddd;
            background-Color:cornsilk;

        }

        .general-data-input-settings {

            width:300px;
            height:20px;
            padding:0px;
            font-Size: 14px;
            color:blue;
            border:1px solid #dddddd;
            background-Color:cornsilk;

        }

        .button_cercle {
            margin: 5px;
            padding: 10px;
            background-color: #000000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .button_cercle:hover {
            background-color: #959595;
        }

        .custom-icon {
            font-size: 10px; /* Taille réduite de l'icône */
        }

 




    </style>

</head>
<body>

   

    <div id="button-container">
        
            <!-- Buttons will be added here -->
            <button class="custom-button custom-button-25"  title="Données générales" id="form"> </button> 
            <button class="custom-button custom-button-1" title="Nouveau fichier" onclick="new_file()"> </button>
            <button class="custom-button custom-button-2" title="Ouvrir un fichier" id="openShapesButton"> </button>
            <input type="file" id="openShapes" style="display: none;">
            <input type="file" id="ImportShapes" style="display: none;">
            <button class="custom-button custom-button-3" title="Enregistrer" id="save" onclick="save()"> </button>
            <button class="custom-button custom-button-4" title="Enregistrer sous" id="save_as" onclick="save_as()"> </button>
            <button class="custom-button custom-button-30" title="précédent" id="previous" onclick="previous()"> </button>
            <button class="custom-button custom-button-31" title="suivant" id="next" onclick="next()"> </button>
            <button class="custom-button custom-button-5" title="Afficher les résultats" id="print-results" onclick="print_results()"> </button>
            <button class="custom-button custom-button-6" title="Créer une électrode horizontale" onclick="ligneh()"> </button>
            <button class="custom-button custom-button-29" title="Créer une électrode verticale" onclick="lignev()"> </button>
            <button class="custom-button custom-button-28" title="Créer un maillage de terre" id="maillage"> </button>
            <button class="custom-button custom-button-27" title="Créer un élément conducteur en forme d'arc de cercle" id="cercle"> </button>
            <button class="custom-button custom-button-8" title="retirer les résultats de la scene" id="delete" onclick="removeresults()"> </button>
            <button class="custom-button custom-button-9"  title="Lancer le calcul" id="run" onclick="programme_principal()"> </button>
            <button class="custom-button custom-button-26"  title="Conformité de la prise de terre - Rouge: Non conforme - Vert: Conforme" id="results" onclick=""> </button>
            <button class="custom-button custom-button-10"   title="supprimer un object" onclick="delete_object()"> </button>
            <button class="custom-button custom-button-12"  title="vue isommétrique" onclick="isometric_view ()"> </button>
            <button class="custom-button custom-button-13"  title="vue de dessus" onclick="top_view ()"> </button>
            <button class="custom-button custom-button-14"  title="vue de face" onclick="front_view ()"> </button>
            <button class="custom-button custom-button-15"  title="vue arrière" onclick="back_view ()"> </button>
            <button class="custom-button custom-button-16"  title="vue de gauche" onclick="left_view ()"> </button>
            <button class="custom-button custom-button-17"  title="vue de droite" onclick="right_view ()"> </button>
            <button class="custom-button custom-button-23"  title="déplacer un object dans le sens horizontal" id="dragObjectButton" onclick="drag()"> </button>
            <button class="custom-button custom-button-18"   title="selectionner l'object" id="SelectObjectButton" onclick="selection ()"> </button>
            <button class="custom-button custom-button-19"  title="zoom avant" onclick="zoom_in ()"> </button>
            <button class="custom-button custom-button-20"  title="zoom arrière" onclick="zoom_out ()"> </button>
            <button class="custom-button custom-button-24"  title="Paramètres" id="settings"> </button>
        
    </div>

 
    <div class="container" id="sceneContainer">

        <div class="overlay" id="overlay-settings"></div>
    
        <div class="popup_settings" id="popup-settings">

            <div class="popup-title">Paramètres</div>

            <div class="container" id="data-container-settings">
                <label for="resolution" class="label_input_field">Résolution (m) :</label>
                <input type="range" style="width: 150px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="resolution" min="0.1" step="0.1" max="50" value="1">
                <span id="resolution-value">1</span>
            </div>
           

            <div class="container" id="data-container-settings">
        
                <label for="camera-position" class="label_input_field">Position de la caméra (m) :</label>
               <input type="range" style="width: 100px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="camera-position" min="50" max="300" value="100">
                <span id="camera-position-value">100</span>
        
            </div>

            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_scene" class="label_input_field">Couleur de la scene :</label>
                    <input type="color" id="Couleur_scene" style="width: 50px; height: 20px;" value="#000000">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_object" class="label_input_field">Couleur de la selection :</label>
                    <input type="color" id="Couleur_object" style="width: 50px; height: 20px;" value="#00ff00">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_lignes" class="label_input_field">Couleur des lignes :</label>
                    <input type="color" id="Couleur_lignes" style="width: 50px; height: 20px;" value="#ff00ff">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">
        
                
                <div class="color-picker-container">
                    <label for="Couleur_resultats" class="label_input_field">Couleur des résultats :</label>
                    <input type="color" id="Couleur_resultats" style="width: 50px; height: 20px;" value="#E3DB0D">
                </div>

        
            </div>


        </div>


        <div class="overlay" id="overlay-form"></div>
    
        <div class="popup_form" id="popup-form">

            <div class="popup-title">Données générales</div>
           
            <div class="container" id="data-container-settings"> 
                <label for="nom_projet" class="label_input_field">Nom du projet:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_projet" style="color: blue;" value="Nom du projet">
            </div>

            <div class="container" id="data-container-settings"> 
                <label for="nom_redacteur" class="label_input_field">Nom du rédacteur:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_redacteur" style="color: blue;" value="Nom et prénom">
            </div>

            <div class="container" id="data-container-settings"> 
                <label for="nom_societe" class="label_input_field">Nom de la société:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_societe" style="color: blue;" value="Nom de la société">
            </div>
 

        </div>


        <div class="overlay" id="overlay-cercle"></div>
    
        <div class="popup_cercle" id="popup-cercle">

            <div class="popup-title">Création d'un arc de cercle</div>

          
            <div class="container" id="data-container-cercle"> 
                <label for="segments" class="label_input_field">Nombre de segments:</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="segments" style="color: blue;" value="10">
            </div>

            <div class="container" id="data-container-cercle"> 
                <label for="theta0" class="label_input_field">Angle de début (°):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="theta0" style="color: blue;" value="0">
            </div>

            <div class="container" id="data-container-cercle"> 
                <label for="theta1" class="label_input_field">Angle de fin (°):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="theta1" style="color: blue;" value="360">
            </div>

            <div class="container" id="data-container-cercle"> 
                <label for="rayon_cercle" class="label_input_field">Rayon de l'arc (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="rayon_cercle" style="color: blue;" value="5">
            </div>

            <div class="container" id="data-container-cercle"> 
                <label for="x0_cercle" class="label_input_field">Centre de l'arc X0 (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="x0_cercle" style="color: blue;" value="0">
            </div>

            <div class="container" id="data-container-cercle"> 
                <label for="y0_cercle" class="label_input_field">Centre de l'arc Y0 (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="y0_cercle" style="color: blue;" value="0">
            </div>


            <div class="container" id="data-container-cercle"> 
                <label for="Profondeur_cercle" class="label_input_field">Profondeur (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="Profondeur_cercle" style="color: blue;" value="-0.5">
            </div>

            <div>
                <button class="button_cercle" id="validate-popup-btn-cercle">Valider</button>
                <button class="button_cercle" id="close-popup-btn-cercle">Fermer</button>

            </div>
 

        </div>


        <div class="overlay" id="overlay-maillage"></div>
    
        <div class="popup_maillage" id="popup-maillage">

            <div class="popup-title">Création d'un maillage</div>

          
            <div class="container" id="data-container-maillage"> 
                <label for="longueur-maillage" class="label_input_field">Longueur du maillage (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="longueur-maillage" style="color: blue;" value="50">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="largeur-maillage" class="label_input_field">Largeur du maillage (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="largeur-maillage" style="color: blue;" value="50">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="nombre-conducteurs-horizontaux" class="label_input_field">Nombre de conducteurs horizontaux:</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nombre-conducteurs-horizontaux" style="color: blue;" value="6">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="nombre-conducteurs-verticaux" class="label_input_field">Nombre de conducteurs verticaux:</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nombre-conducteurs-verticaux" style="color: blue;" value="6">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="x0-maillage" class="label_input_field">Centre du maillage X0 (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="x0-maillage" style="color: blue;" value="0">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="y0-maillage" class="label_input_field">Centre du maillage Y0 (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="y0-maillage" style="color: blue;" value="0">
            </div>


            <div class="container" id="data-container-maillage"> 
                <label for="Profondeur-maillage" class="label_input_field">Profondeur (m):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="Profondeur-maillage" style="color: blue;" value="-0.5">
            </div>

            <div class="container" id="data-container-maillage"> 
                <label for="rayon-conducteurs-maillage" class="label_input_field">Diamètre des conducteurs (mm):</label>
                <input type="number" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="rayon-conducteurs-maillage" style="color: blue;" value="8.0">
            </div>

            <div>
                <button class="button_cercle" id="validate-popup-btn-maillage">Valider</button>
                <button class="button_cercle" id="close-popup-btn-maillage">Fermer</button>

            </div>
 

        </div>

      
    </div>


      
    </div>




    <div class="container" id="data-container">

        <label for="resistivite" class="label_input_field">Résistivité du sol (Ohm.m)</label>
        <!-- Input element for the second pair -->
                   
        <div>
        <input type="text" class="general-data-input" id="resistivite"  value="500">
        </div>

    </div>


    <div class="container" id="item-list">
    
    </div>


    <div class="container" id="label-list">
               
    </div>


<!-- Include the necessary dependencies -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.js"></script>
<script src="OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>


<script>



///////////////////////POPUP SETTINGS /////////////////////////////////////////
const popup_settings = document.getElementById('popup-settings');
const overlay_settings = document.getElementById('overlay-settings');
let setting_apparition = false;

// Fonction pour afficher la popup
function showPopup_settings() {
    popup_settings.style.display = "block";
    overlay_settings.style.display = "block";
    setting_apparition = true;
}

// Fonction pour masquer la popup
function hidePopup_settings() {
    popup_settings.style.display = "none";
    overlay_settings.style.display = "none";
    setting_apparition = false;
}

// Gestionnaire pour ouvrir la popup
document.getElementById('settings').addEventListener('click', showPopup_settings);

// Gestionnaire global pour détecter les clics hors de la popup
document.addEventListener('click', function(event) {
    if (setting_apparition && !popup_settings.contains(event.target) && event.target.id !== 'settings') {
        hidePopup_settings();
    }
});

// Gestionnaire pour fermer avec la touche Escape
document.addEventListener('keydown', function(event) {
    if (event.key === "Escape" && setting_apparition) {
        hidePopup_settings();
    }
});

//////////////////////////////////////////////////////////

///////////////////////POPUP FORM /////////////////////////////////////////
const popup_form = document.getElementById('popup-form');
const overlay_form = document.getElementById('overlay-form');
let form_apparition = false;

// Fonction pour afficher la popup
function showPopup_form() {
    popup_form.style.display = "block";
    overlay_form.style.display = "block";
    form_apparition = true;
}

// Fonction pour masquer la popup
function hidePopup_form() {
    popup_form.style.display = "none";
    overlay_form.style.display = "none";
    form_apparition = false;
}

// Gestionnaire pour ouvrir la popup
document.getElementById('form').addEventListener('click', showPopup_form);

// Gestionnaire global pour détecter les clics hors de la popup
document.addEventListener('click', function(event) {
    if (form_apparition && !popup_form.contains(event.target) && event.target.id !== 'form') {
        hidePopup_form();
    }
});

// Gestionnaire pour fermer avec la touche Escape
document.addEventListener('keydown', function(event) {
    if (event.key === "Escape" && form_apparition) {
        hidePopup_form();
    }
});

//////////////////////////////////////////////////////////


const popup_cercle = document.getElementById('popup-cercle');
const overlay_cercle = document.getElementById('overlay-cercle');
const validatePopupBtn_cercle = document.getElementById('validate-popup-btn-cercle');
const closePopupBtn_cercle = document.getElementById('close-popup-btn-cercle');

closePopupBtn_cercle.addEventListener('click', function() {
    popup_cercle.style.display = "none";
    overlay_cercle.style.display = "none";
});

var segments=parseFloat(document.getElementById('segments').value);  
var theta0=parseFloat(document.getElementById('theta0').value);  
var theta1=parseFloat(document.getElementById('theta1').value); 
var rayon_cercle=parseFloat(document.getElementById('rayon_cercle').value); 
var x0_cercle=parseFloat(document.getElementById('x0_cercle').value); 
var y0_cercle=parseFloat(document.getElementById('y0_cercle').value);
var Profondeur_cercle=parseFloat(document.getElementById('Profondeur_cercle').value);

validatePopupBtn_cercle.addEventListener('click', function() {
    popup_cercle.style.display = "none";
    overlay_cercle.style.display = "none";
    segments=parseFloat(document.getElementById('segments').value);  
    theta0=parseFloat(document.getElementById('theta0').value);  
    theta1=parseFloat(document.getElementById('theta1').value); 
    rayon_cercle=parseFloat(document.getElementById('rayon_cercle').value); 
    x0_cercle=parseFloat(document.getElementById('x0_cercle').value); 
    y0_cercle=parseFloat(document.getElementById('y0_cercle').value);
    Profondeur_cercle=parseFloat(document.getElementById('Profondeur_cercle').value);
    arc();

    saveState();

});


document.getElementById('cercle').addEventListener('click', function() {

    popup_cercle.style.display = "block";
    overlay_cercle.style.display = "block";

});

const popup_maillage = document.getElementById('popup-maillage');
const overlay_maillage = document.getElementById('overlay-maillage');
const validatePopupBtn_maillage = document.getElementById('validate-popup-btn-maillage');
const closePopupBtn_maillage = document.getElementById('close-popup-btn-maillage');

closePopupBtn_maillage.addEventListener('click', function() {
    popup_maillage.style.display = "none";
    overlay_maillage.style.display = "none";
});

var longueur_maillage=parseFloat(document.getElementById('longueur-maillage').value);  
var largeur_maillage=parseFloat(document.getElementById('largeur-maillage').value);  
var nombre_conducteurs_horizontaux=parseFloat(document.getElementById('nombre-conducteurs-horizontaux').value); 
var nombre_conducteurs_verticaux=parseFloat(document.getElementById('nombre-conducteurs-verticaux').value); 
var x0_maillage=parseFloat(document.getElementById('x0-maillage').value); 
var y0_maillage=parseFloat(document.getElementById('y0-maillage').value);
var Profondeur_maillage=parseFloat(document.getElementById('Profondeur-maillage').value);
var rayon_conducteurs_maillage=parseFloat(document.getElementById('rayon-conducteurs-maillage').value);

validatePopupBtn_maillage.addEventListener('click', function() {
    popup_maillage.style.display = "none";
    overlay_maillage.style.display = "none";
    longueur_maillage=parseFloat(document.getElementById('longueur-maillage').value);  
    largeur_maillage=parseFloat(document.getElementById('largeur-maillage').value);  
    nombre_conducteurs_horizontaux=parseFloat(document.getElementById('nombre-conducteurs-horizontaux').value); 
    nombre_conducteurs_verticaux=parseFloat(document.getElementById('nombre-conducteurs-verticaux').value); 
    x0_maillage=parseFloat(document.getElementById('x0-maillage').value); 
    y0_maillage=parseFloat(document.getElementById('y0-maillage').value);
    Profondeur_maillage=parseFloat(document.getElementById('Profondeur-maillage').value);
    rayon_conducteurs_maillage=parseFloat(document.getElementById('rayon-conducteurs-maillage').value);
    maillage();

    saveState();

});


document.getElementById('maillage').addEventListener('click', function() {

    popup_maillage.style.display = "block";
    overlay_maillage.style.display = "block";

});


var longueur_e=1.0;

document.getElementById("resolution").addEventListener("input", function() {
    document.getElementById("resolution-value").textContent = this.value;
    longueur_e=parseFloat(this.value);

});

var Couleur_scene='#000000';

document.getElementById('Couleur_scene').addEventListener('change', function() {
    Couleur_scene = document.getElementById('Couleur_scene').value;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene

    saveState();
});


var Couleur_object='#00ff00';

document.getElementById('Couleur_object').addEventListener('change', function() {
    Couleur_object = document.getElementById('Couleur_object').value;

    saveState();
});

var Couleurlignes='#ff00ff';

document.getElementById('Couleur_lignes').addEventListener('change', function() {
    Couleurlignes = document.getElementById('Couleur_lignes').value;

    if (lines.length>=1) {

    for (let i = 0; i < lines.length; i++) {

        lines[i].material.color.set(Couleurlignes);

    }

    }

    saveState();
});

var couleur_resultats='#E3DB0D';

document.getElementById('Couleur_resultats').addEventListener('change', function() {
    couleur_resultats = document.getElementById('Couleur_resultats').value;
});

var camera_position=100;

document.getElementById('camera-position').addEventListener("input", function() {
    document.getElementById('camera-position-value').textContent = this.value;
    camera_position = parseFloat(this.value);
    camera.position.set(camera_position, camera_position, camera_position);
    camera.lookAt(0, 0, 0);
    controls.update();
});


nomprojet='Projet N°';

document.getElementById('nom_projet').addEventListener('change',function() {

nomprojet = document.getElementById('nom_projet').value;

saveState();

});

nomredacteur='Nom Prénom';

document.getElementById('nom_redacteur').addEventListener('change',function() {

nomredacteur = document.getElementById('nom_redacteur').value;

saveState();

});


nomsociete='Nom de la société';
document.getElementById('nom_societe').addEventListener('change',function() {

nomsociete = document.getElementById('nom_societe').value;

saveState();

});






function print_results() {

    const newWindow = window.open('aaaaa', '_blank');

    const newDoc = newWindow.document;


    //const canvas = renderer.domElement; // Access the canvas element used by Three.js
    //const sceneImage = canvas.toDataURL('image/png'); // Convert canvas to an image in base64


    // Obtenir la date actuelle
    const currentDate = new Date();
    const formattedDate = currentDate.toLocaleDateString('fr-FR', {
        Année: 'numeric',
        Mois: 'long',
        Jour: 'numeric'
    });


    const versionlogicielle='ELP-RT-02-08-01A';
    const normeReference='NF EN 62305-3';

    

    const rho = document.getElementById('resistivite').value;

    var statut;
    var color_statut;

    if (R<=10) {

        statut='OUI';
        color_statut='#006400';


    } else {

        statut='NON';
        color_statut='#ff0000';

    }


    const html = `
    <html>
    <head>
        <title>CALCUL DE LA RESISTANCE DE TERRE ${''} </title>
            <style>
            @media print {
                    @page {
                        margin-left: 1cm;
                        margin-right: 1cm;
                        margin-top: 2cm;
                        margin-bottom: 1cm;
                    }
                    body {
                        margin: 0;
                    }
                    .page-number:after {
                        content: counter(page);
                    }
                    .page-number {
                        position: fixed;
                        bottom: 0;
                        width: 100%;
                        text-align: center;
                    }
                }

                
                /* Optional: Additional CSS styles for the output window */
            </style>
    </head>
    <body>

    <h3 style="text-decoration: underline; text-align: center;">DONNEES DE SORTIE LOGICIELLE</h3>
    <p style="text-align: center">Version logicielle: <span style="color: blue;">${versionlogicielle}</span></p>
    <p style="text-align: center">Nom du projet: <span style="color: blue;">${nomprojet}</span></p>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">DONNEES GENERALES</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <p>Date: <span style="color: blue;">${formattedDate}</span></p>
    <p>Norme de référence: <span style="color: blue;">${normeReference}</span></p>
    <p>Nom et prénom du rédacteur: <span style="color: blue;">${nomredacteur}</span></p>
    <p>Nom de la société: <span style="color: blue;">${nomsociete}</span></p>
    <p>Résistivité du sol: <span style="color: blue;">${rho} Ohm.m</span></p>


    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">CONDUCTEURS SAISIS</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>

    <div id="enteredlines-data-container"></div>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">RESULTATS DE CALCUL</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>

    <div id="results-container"></div>
    
    </body>
    </html>
    `;


    newDoc.open();

    newDoc.write(html);
    newDoc.close();

    newWindow.onload = function () {

    const enteredlinesdatacontainer = newDoc.getElementById('enteredlines-data-container');
    const resultscontainer = newDoc.getElementById('results-container');
    

    for (let i = 0; i < group_data_cube.length; i++) {

        const x0_1=parseFloat(group_data_cube[i].prevPosX);
        const y0_1=parseFloat(group_data_cube[i].prevPosY);
        const Profondeur=parseFloat(group_data_cube[i].prevDepth);
        const Longueur=parseFloat(group_data_cube[i].prevLength);
        const alphaz=parseFloat(group_data_cube[i].prevRotZ);
        const alphay=parseFloat(group_data_cube[i].prevRotY);
        const alphax=parseFloat(group_data_cube[i].prevRotX);
        const Rayon=parseFloat(group_data_cube[i].prevRadius);
 
            enteredlinesdatacontainer.innerHTML += `
            <h4 style="text-decoration: underline;">${group_data_cube[i].text_new_item}</h4>

            
            <div style="display: flex; flex-wrap: wrap;">
            <p style="margin: 0 10px 0 0; padding: 0;">Point de départ: <span style="color: blue;"></span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (X0): <span style="color: blue;">${x0_1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Y0): <span style="color: blue;">${y0_1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Profondeur : <span style="color: blue;">${Profondeur} m</span></p>
            </div>

            <div style="display: flex; flex-wrap: wrap;">
            <p style="margin: 0 10px 0 0; padding: 0;">Longueur: <span style="color: blue;">${Longueur} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Angle/Z : <span style="color: blue;">${alphaz} °</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Angle/Y : <span style="color: blue;">${alphay} °</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Angle/X : <span style="color: blue;">${alphax} °</span></p>

            </div>


        `;
    

    }

    

    resultscontainer.innerHTML += `
            
            
            <p style="margin: 0 10px 0 0; padding: 0;">Valeur de résistance de terre obtenue: <span style="color: blue;">${R.toFixed(2)} &Omega;</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Valeur de résistance recommandée par la norme: <span style="color: blue;">&lt; 10 &Omega;</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;font-weight: bold;">Prise de terre conforme (OUI/NON): <span style="color: ${color_statut};">${statut}</span></p>


        `;


    
    newWindow.print();

    const tempWindow = window.open('', '_blank', 'width=1,height=1');
    tempWindow.blur(); // Perdre le focus de la fenêtre temporaire
    window.focus(); // Revenir à la fenêtre principale
    setTimeout(() => tempWindow.close(), 100); // Fermer la fenêtre temporaire


}

}





        /////////////////////////////////////////////////////////////////////


 

        var group_scene = new THREE.Group();
        groups_data=[];
        const originalColorsByGroup = new Map();
        inputdata=null;
        group_data_cube=[];
        index=null;
        var points=null;

        let itemCounter_cube = 0;
        let itemCounter_f = 0;
        let itemCounter_cy = 0;
        let itemCounter_cyh = 0;
        let itemCounter_tsp = 0;
        let itemCounter_tcy = 0;
        let itemCounter_co = 0;
        let itemCounter_line = 0;
        let itemCounter_pda = 0;
        let itemCounter_pts = 0;
        let itemCounter_ca = 0;
        var currentView = null;//'perspective';
        var currentView_1 =null; //'perspective';
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var Rayon_p=20.;
        let initialFov
        let initialCameraPosition 
        let initialCameraRotation
        var snp=[];
        var test_snp=0;
        var sprites=[];


        
        
        //////////////////////////////INTITIALISE THE SCENE//////////////////////////////////////////////////////

        init();
        

        //var camera_position=50;


        function init() {

      
            scene = new THREE.Scene();
            camera_position=100.;
            camera_position_z=50.;
            currentView='perspective';
            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            //camera = new THREE.PerspectiveCamera(75, window.innerWidth /window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(Couleur_scene, 1);

            
            camera.position.set(camera_position, camera_position, camera_position); // Default top view
            camera.lookAt(0, 0, 0);
            //renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('sceneContainer').appendChild(renderer.domElement);

            initialFov = camera.fov;
            initialCameraPosition = camera.position.clone();
            initialCameraRotation=camera.rotation.clone();
        
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            controls.reset();
  

    }

    
    ///////////////////////////////ADDED FOR VIEWS//////////////////////////////////////////////////////////

        axes_creation ();
        light_interraction ();
        

        ////////////////////////////////////////AXES CREATION/////////////////////////////////////////////////////
           
    
    
    
    function axes_creation () {
 
        var xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(100, 0, 0) // direction of the X-axis
        ]);
        var xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
        group_scene.add(xAxis);
        scene.add(xAxis);
        xAxis.name = 'xAxis';

        // Create line for Y-axis
        var yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 100, 0) // direction of the Y-axis
        ]);
        var yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x006400 });
        var yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
        group_scene.add(yAxis);
        scene.add(yAxis);
        yAxis.name = 'yAxis';

        // Create line for Z-axis
        var zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 100) // direction of the Z-axis
        ]);
        var zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        var zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
        group_scene.add(zAxis);
        scene.add(zAxis);
        zAxis.name = 'zAxis';

    }
    
        //////////////////////////////////////////////////////////////////////////////////////////////////////////


        function light_interraction () {
        // Add ambient light
        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Add directional light
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        }



    ///////////////////////////////////////////////ANIMATE FUNCTION//////////////////////////////////////////
    function animate() {


        requestAnimationFrame(animate);
               
        renderer.render(scene, camera);

            
        controls.update(); // Update controls continuously

        controls.enabled=true;
          


    }


        function top_view() {


            controls.reset();
            //cameraZ = new THREE.OrthographicCamera(-size * aspect, size * aspect, size, -size, near, far);
            camera.position.set(0, camera_position, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }

        function front_view() {

            controls.reset();         
            camera.position.set(0, 0, camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

  
        }


        function back_view() {

            controls.reset();           
            camera.position.set(0, 0, -camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        function left_view() {

            controls.reset();           
            camera.position.set(-camera_position, 0, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        function right_view() {
           
            controls.reset();
            camera.position.set(camera_position, 0, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        // Function to switch to front view
  
        function isometric_view() {
            controls.reset();
            camera.position.set(camera_position, camera_position, camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);
        }

        
         function zoom_in() {

            
            if (currentView==='perspective') {

  
            camera.fov -= 5; // Decrease the field of view to zoom in
            camera.updateProjectionMatrix(); // Update the camera's projection matrix

            } else {

                
            var aspect = window.innerWidth / window.innerHeight;
            var size = 5;
            var near = -10;
            var far = 10;
            var zoomFactor = +5;

            cameraX.left += zoomFactor * aspect;
            cameraX.right -= zoomFactor * aspect;
            cameraX.top -= zoomFactor;
            cameraX.bottom += zoomFactor;
            cameraX.updateProjectionMatrix();

            cameraXM.left += zoomFactor * aspect;
            cameraXM.right -= zoomFactor * aspect;
            cameraXM.top -= zoomFactor;
            cameraXM.bottom += zoomFactor;
            cameraXM.updateProjectionMatrix();

            cameraY.left += zoomFactor * aspect;
            cameraY.right -= zoomFactor * aspect;
            cameraY.top -= zoomFactor;
            cameraY.bottom += zoomFactor;
            cameraY.updateProjectionMatrix();

            cameraYM.left += zoomFactor * aspect;
            cameraYM.right -= zoomFactor * aspect;
            cameraYM.top -= zoomFactor;
            cameraYM.bottom += zoomFactor;
            cameraYM.updateProjectionMatrix();

            cameraZ.left += zoomFactor * aspect;
            cameraZ.right -= zoomFactor * aspect;
            cameraZ.top -= zoomFactor;
            cameraZ.bottom += zoomFactor;
            cameraZ.updateProjectionMatrix();

                // Similar adjustments for cameraY and cameraZ if need

                }



            }
        
        
        function zoom_out() {
            
            
            if (currentView==='perspective') {
  
            camera.fov += 5; // Decrease the field of view to zoom in
            camera.updateProjectionMatrix(); // Update the camera's projection matrix

            } else {
        
            var aspect = window.innerWidth / window.innerHeight;
            var size = 5;
            var near = -10;
            var far = 10;
            var zoomFactor = +5;

            cameraX.left -= zoomFactor * aspect;
            cameraX.right += zoomFactor * aspect;
            cameraX.top += zoomFactor;
            cameraX.bottom -= zoomFactor;
            cameraX.updateProjectionMatrix();

            cameraXM.left -= zoomFactor * aspect;
            cameraXM.right += zoomFactor * aspect;
            cameraXM.top += zoomFactor;
            cameraXM.bottom -= zoomFactor;
            cameraXM.updateProjectionMatrix();

            cameraY.left -= zoomFactor * aspect;
            cameraY.right += zoomFactor * aspect;
            cameraY.top += zoomFactor;
            cameraY.bottom -= zoomFactor;
            cameraY.updateProjectionMatrix();

            cameraYM.left -= zoomFactor * aspect;
            cameraYM.right += zoomFactor * aspect;
            cameraYM.top += zoomFactor;
            cameraYM.bottom -= zoomFactor;
            cameraYM.updateProjectionMatrix();

            cameraZ.left -= zoomFactor * aspect;
            cameraZ.right += zoomFactor * aspect;
            cameraZ.top += zoomFactor;
            cameraZ.bottom -= zoomFactor;
            cameraZ.updateProjectionMatrix();

        // Similar adjustments for cameraY and cameraZ if need

        }


        }

 
 

        sol()


        var floor;
       
   
        function sol() {
            
            var length_s=1000.0;
            var width_s=1000.0;
            var height_s=0.1;
            var x_s=0.0;
            var y_s=0.0;
            var z_s=-0.1;
            //var rotationAngle=0; //degré
            //var rotationAngle=rotationAngle*Math.PI/180;
            var cubeGeometry_s = new THREE.BoxGeometry(length_s,height_s,width_s);
            var cubeMaterial_s = new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 });
            floor = new THREE.Mesh(cubeGeometry_s, cubeMaterial_s);
            floor.position.set(x_s, z_s, y_s);
            floor.userData.id='floor'
            //floor.rotation.z=rotationAngle;

            group_scene.add(floor);
            
            scene.add(floor);

            renderer.render(scene, camera);

            //document.addEventListener('click', onClick, false);

            floor.name='floor';


        }

        nomprojet='Projet N°';

        document.getElementById('nom_projet').addEventListener('change',function() {

        nomprojet = document.getElementById('nom_projet').value;

        });

        nomredacteur='Nom Prénom';

        document.getElementById('nom_redacteur').addEventListener('change',function() {

        nomredacteur = document.getElementById('nom_redacteur').value;

        });


        nomsociete='Nom de la société';
        document.getElementById('nom_societe').addEventListener('change',function() {

        nomsociete = document.getElementById('nom_societe').value;

        });

        rho=500;
        document.getElementById('resistivite').addEventListener('change',function() {

            rho = parseFloat(document.getElementById('resistivite').value);

            if (rho<=0 || isNaN(rho)) {

                document.getElementById('resistivite').value='500';

                return

            } 

 

        });
 

        function hideInputFields() {

            
        var labelsInputContainer = document.getElementById('label-list');

        if (labelsInputContainer) {
        labelsInputContainer.innerHTML = ''; // Clear the container

        }


        }


        function show_input_fields (newItem,group,index){
           
        hideInputFields()
     
        var color_cube=Couleurlignes;
 


 

var labelsInputContainer = document.getElementById('label-list');
var select = document.createElement("select");
var select_2 = document.createElement("select");

// Create and append label and input fields for cube dimensions
var RenameLabelDiv = document.createElement('div');
var RenameLabel = document.createElement('label');
RenameLabel.textContent = 'Renommer:';
RenameLabel.style.display = 'block'; // Ensure label is on its own line
RenameLabelDiv.appendChild(RenameLabel);
var RenameInput = document.createElement('input');
RenameInput.type = 'text';
//widthInput.style.marginLeft = '150px';
RenameInput.placeholder = 'Nom de la structure';
RenameInput.value = group_data_cube[index].text_new_item;
//widthInput.style.marginLeft = '50px';
RenameInput.style.color = 'blue'; // Set text color to blue
RenameInput.style.display = 'block'; // Ensure label is on its own line
RenameInput.style.width = '250px'; // Set width
RenameInput.style.height = '20px'; // Set width
RenameInput.style.padding = '0px'; // Adjust padding to match select
RenameInput.style.border = '1px solid #ccc'; // Match border style
RenameInput.style.fontSize = '14px'; // Match font size
RenameInput.style.boxSizing = 'border-box'; // Include padding and border in the width
RenameInput.style.backgroundColor='cornsilk';
RenameInput.addEventListener('input', updateCubeDimensions);
RenameInput.addEventListener('input', saveState);
RenameLabelDiv.appendChild(RenameInput);
labelsInputContainer.appendChild(RenameLabelDiv);

// Create and append label and input fields for cube position
var xLabelDiv = document.createElement('div');
var xLabel = document.createElement('label');
xLabel.textContent = 'Origine X0 (m):';
xLabel.style.display = 'block'; // Ensure label is on its own line
xLabelDiv.appendChild(xLabel);
var xInput = document.createElement('input');
xInput.type = 'number';
xInput.placeholder = 'Entrer la valeur';
xInput.value =group_data_cube[index].prevPosX ;
xInput.style.color = 'blue'; // Set text color to blue
xInput.style.display = 'block'; // Ensure label is on its own line
xInput.style.width = '250px'; // Set width
xInput.style.height = '20px'; // Set width
xInput.style.padding = '0px'; // Adjust padding to match select
xInput.style.border = '1px solid #ccc'; // Match border style
xInput.style.fontSize = '14px'; // Match font size
xInput.style.boxSizing = 'border-box'; // Include padding and border in the width
xInput.style.backgroundColor='cornsilk';
xInput.addEventListener('input', updateCubeDimensions);
xInput.addEventListener('change', saveState);
//xInput.style.marginLeft = '50px';
xLabelDiv.appendChild(xInput);
labelsInputContainer.appendChild(xLabelDiv);

var yLabelDiv = document.createElement('div');
var yLabel = document.createElement('label');
yLabel.textContent = 'Origine Y0 (m):';
yLabel.style.display = 'block'; // Ensure label is on its own line
yLabelDiv.appendChild(yLabel);
var yInput = document.createElement('input');
yInput.type = 'number';
yInput.placeholder = 'Entrer la valeur';
yInput.value = group_data_cube[index].prevPosY;
yInput.style.color = 'blue'; // Set text color to blue
yInput.style.display = 'block'; // Ensure label is on its own line
yInput.style.width = '250px'; // Set width
yInput.style.height = '20px'; // Set width
yInput.style.padding = '0px'; // Adjust padding to match select
yInput.style.border = '1px solid #ccc'; // Match border style
yInput.style.fontSize = '14px'; // Match font size
yInput.style.boxSizing = 'border-box'; // Include padding and border in the width
yInput.style.backgroundColor='cornsilk';
yInput.addEventListener('input', updateCubeDimensions);
yInput.addEventListener('change', saveState);
//yInput.style.marginLeft = '50px';
yLabelDiv.appendChild(yInput);
labelsInputContainer.appendChild(yLabelDiv);

var LongueurLabelDiv = document.createElement('div');
var LongueurLabel = document.createElement('label');
LongueurLabel.textContent = 'Longueur du conducteur (m):';
LongueurLabel.style.display = 'block'; // Ensure label is on its own line
LongueurLabelDiv.appendChild(LongueurLabel);
var LongueurInput = document.createElement('input');
LongueurInput.type = 'number';
LongueurInput.placeholder = 'Entrer la valeur';
LongueurInput.value = group_data_cube[index].prevLength;
LongueurInput.style.color = 'blue'; // Set text color to blue
LongueurInput.style.display = 'block'; // Ensure label is on its own line
LongueurInput.style.width = '250px'; // Set width
LongueurInput.style.height = '20px'; // Set width
LongueurInput.style.padding = '0px'; // Adjust padding to match select
LongueurInput.style.border = '1px solid #ccc'; // Match border style
LongueurInput.style.fontSize = '14px'; // Match font size
LongueurInput.style.boxSizing = 'border-box'; // Include padding and border in the width
LongueurInput.style.backgroundColor='cornsilk';
LongueurInput.addEventListener('input', updateCubeDimensions);
LongueurInput.addEventListener('change', saveState);
//yInput.style.marginLeft = '50px';
LongueurLabelDiv.appendChild(LongueurInput);
labelsInputContainer.appendChild(LongueurLabelDiv);

var DepthLabelDiv = document.createElement('div');
var DepthLabel = document.createElement('label');
DepthLabel.textContent = 'Profondeur du conducteur (m):';
DepthLabel.style.display = 'block'; // Ensure label is on its own line
DepthLabelDiv.appendChild(DepthLabel);
var DepthInput = document.createElement('input');
DepthInput.type = 'number';
DepthInput.placeholder = 'Entrer la valeur';
DepthInput.value = group_data_cube[index].prevDepth;
DepthInput.style.color = 'blue'; // Set text color to blue
DepthInput.style.display = 'block'; // Ensure label is on its own line
DepthInput.style.width = '250px'; // Set width
DepthInput.style.height = '20px'; // Set width
DepthInput.style.padding = '0px'; // Adjust padding to match select
DepthInput.style.border = '1px solid #ccc'; // Match border style
DepthInput.style.fontSize = '14px'; // Match font size
DepthInput.style.boxSizing = 'border-box'; // Include padding and border in the width
DepthInput.style.backgroundColor='cornsilk';
DepthInput.addEventListener('input', updateCubeDimensions);
DepthInput.addEventListener('change', saveState);
//zInput.style.marginLeft = '50px';
DepthLabelDiv.appendChild(DepthInput);
labelsInputContainer.appendChild(DepthLabelDiv);

var RadiusLabelDiv = document.createElement('div');
var RadiusLabel = document.createElement('label');
RadiusLabel.textContent = 'Diamètre du conducteur (mm):  ';
RadiusLabel.style.display = 'block'; // Ensure label is on its own line
RadiusLabelDiv.appendChild(RadiusLabel);
var RadiusInput = document.createElement('input');
RadiusInput.type = 'number';
//widthInput.style.marginLeft = '150px';
RadiusInput.placeholder = 'Saisir la valeur';
RadiusInput.value = group_data_cube[index].prevRadius; 
//widthInput.style.marginLeft = '50px';
RadiusInput.style.color = 'blue'; // Set text color to blue
RadiusInput.style.display = 'block'; // Ensure label is on its own line
RadiusInput.style.width = '250px'; // Set width
RadiusInput.style.height = '20px'; // Set width
RadiusInput.style.padding = '0px'; // Adjust padding to match select
RadiusInput.style.border = '1px solid #ccc'; // Match border style
RadiusInput.style.fontSize = '14px'; // Match font size
RadiusInput.style.boxSizing = 'border-box'; // Include padding and border in the width
RadiusInput.style.backgroundColor='cornsilk';
RadiusInput.step = '0.1'; // Par exemple, pour un pas de 0.1
RadiusInput.addEventListener('input', updateCubeDimensions);
RadiusInput.addEventListener('change', saveState);
RadiusLabelDiv.appendChild(RadiusInput);
labelsInputContainer.appendChild(RadiusLabelDiv);

var alphazLabelDiv = document.createElement('div');
var alphazLabel = document.createElement('label');
alphazLabel.textContent = 'Angle de rotation/Z (°):  ';
alphazLabel.style.display = 'block'; // Ensure label is on its own line
alphazLabelDiv.appendChild(alphazLabel);
var alphazInput = document.createElement('input');
alphazInput.type = 'number';
//widthInput.style.marginLeft = '150px';
alphazInput.placeholder = 'Saisir la valeur';
alphazInput.value = group_data_cube[index].prevRotZ; 
//widthInput.style.marginLeft = '50px';
alphazInput.style.color = 'blue'; // Set text color to blue
alphazInput.style.display = 'block'; // Ensure label is on its own line
alphazInput.style.width = '250px'; // Set width
alphazInput.style.height = '20px'; // Set width
alphazInput.style.padding = '0px'; // Adjust padding to match select
alphazInput.style.border = '1px solid #ccc'; // Match border style
alphazInput.style.fontSize = '14px'; // Match font size
alphazInput.style.boxSizing = 'border-box'; // Include padding and border in the width
alphazInput.style.backgroundColor='cornsilk';
alphazInput.step = '0.1'; // Par exemple, pour un pas de 0.1
alphazInput.addEventListener('input', updateCubeDimensions);
alphazInput.addEventListener('change', saveState);
alphazLabelDiv.appendChild(alphazInput);
labelsInputContainer.appendChild(alphazLabelDiv);

var alphayLabelDiv = document.createElement('div');
var alphayLabel = document.createElement('label');
alphayLabel.textContent = 'Angle de rotation/Y (°):  ';
alphayLabel.style.display = 'block'; // Ensure label is on its own line
alphayLabelDiv.appendChild(alphayLabel);
var alphayInput = document.createElement('input');
alphayInput.type = 'number';
//widthInput.style.marginLeft = '150px';
alphayInput.placeholder = 'Saisir la valeur';
alphayInput.value = group_data_cube[index].prevRotY; 
//widthInput.style.marginLeft = '50px';
alphayInput.style.color = 'blue'; // Set text color to blue
alphayInput.style.display = 'block'; // Ensure label is on its own line
alphayInput.style.width = '250px'; // Set width
alphayInput.style.height = '20px'; // Set width
alphayInput.style.padding = '0px'; // Adjust padding to match select
alphayInput.style.border = '1px solid #ccc'; // Match border style
alphayInput.style.fontSize = '14px'; // Match font size
alphayInput.style.boxSizing = 'border-box'; // Include padding and border in the width
alphayInput.style.backgroundColor='cornsilk';
alphayInput.step = '0.1'; // Par exemple, pour un pas de 0.1
alphayInput.addEventListener('input', updateCubeDimensions);
alphayInput.addEventListener('change', saveState);
alphayLabelDiv.appendChild(alphayInput);
labelsInputContainer.appendChild(alphayLabelDiv);


var alphaxLabelDiv = document.createElement('div');
var alphaxLabel = document.createElement('label');
alphaxLabel.textContent = 'Angle de rotation/X (°):  ';
alphaxLabel.style.display = 'block'; // Ensure label is on its own line
alphaxLabelDiv.appendChild(alphaxLabel);
var alphaxInput = document.createElement('input');
alphaxInput.type = 'number';
//widthInput.style.marginLeft = '150px';
alphaxInput.placeholder = 'Saisir la valeur';
alphaxInput.value = group_data_cube[index].prevRotX; 
//widthInput.style.marginLeft = '50px';
alphaxInput.style.color = 'blue'; // Set text color to blue
alphaxInput.style.display = 'block'; // Ensure label is on its own line
alphaxInput.style.width = '250px'; // Set width
alphaxInput.style.height = '20px'; // Set width
alphaxInput.style.padding = '0px'; // Adjust padding to match select
alphaxInput.style.border = '1px solid #ccc'; // Match border style
alphaxInput.style.fontSize = '14px'; // Match font size
alphaxInput.style.boxSizing = 'border-box'; // Include padding and border in the width
alphaxInput.style.backgroundColor='cornsilk';
alphaxInput.step = '0.1'; // Par exemple, pour un pas de 0.1
alphaxInput.addEventListener('input', updateCubeDimensions);
alphaxInput.addEventListener('change', saveState);
alphaxLabelDiv.appendChild(alphaxInput);
labelsInputContainer.appendChild(alphaxLabelDiv);





        xInput.dispatchEvent(new Event('input'));
  

        
  
     
    function updateCubeDimensions() {

        

        test_snp=0;

        



        
       
        


///////////////////////////////////////////////////////STRUCTURE CONIQUE///////////////////////////////////////////////////

const line=lines[index];

textinput=document.getElementById('label-list').querySelectorAll('input')[0].value;
text_new_item=document.getElementById('label-list').querySelectorAll('input')[0].value;

x0_1 = parseFloat(document.getElementById('label-list').querySelectorAll('input')[1].value);
prevPosX=document.getElementById('label-list').querySelectorAll('input')[1].value
y0_1 = parseFloat(document.getElementById('label-list').querySelectorAll('input')[2].value);
prevPosY=document.getElementById('label-list').querySelectorAll('input')[2].value;
Longueur = parseFloat(document.getElementById('label-list').querySelectorAll('input')[3].value);
prevLength=document.getElementById('label-list').querySelectorAll('input')[3].value;
Profondeur = parseFloat(document.getElementById('label-list').querySelectorAll('input')[4].value);
prevDepth=document.getElementById('label-list').querySelectorAll('input')[4].value;
Rayon = parseFloat(document.getElementById('label-list').querySelectorAll('input')[5].value);
prevRadius=document.getElementById('label-list').querySelectorAll('input')[5].value;
alphaz = -parseFloat(document.getElementById('label-list').querySelectorAll('input')[6].value)*Math.PI/180;
prevRotZ=document.getElementById('label-list').querySelectorAll('input')[6].value;
alphay = parseFloat(document.getElementById('label-list').querySelectorAll('input')[7].value)*Math.PI/180;
prevRotY=document.getElementById('label-list').querySelectorAll('input')[7].value;
alphax = -parseFloat(document.getElementById('label-list').querySelectorAll('input')[8].value)*Math.PI/180;
prevRotX=document.getElementById('label-list').querySelectorAll('input')[8].value;

const x0_10=parseFloat(group_data_cube[index].prevPosX);
const y0_10=parseFloat(group_data_cube[index].prevPosY);
const Profondeur0=parseFloat(group_data_cube[index].prevDepth);
const Longueur0=parseFloat(group_data_cube[index].prevLength);
const alphaz0=-parseFloat(group_data_cube[index].prevRotZ)*Math.PI/180;
const alphay0=parseFloat(group_data_cube[index].prevRotY)*Math.PI/180;
const alphax0=-parseFloat(group_data_cube[index].prevRotX)*Math.PI/180;


if (!(x0_10===x0_1 && y0_10===y0_1 && Profondeur0===Profondeur && 
    alphaz0===alphaz && alphay0===alphay && alphax0===alphax && Longueur === Longueur0)) {

    removeAllTextMeshes();
    

}

group_name='line';

if (Rayon<=0 ||
    textinput=='' ||
    isNaN(Rayon) || 
    isNaN(x0_1) ||
    isNaN(y0_1) ||   
    isNaN(alphaz) ||  
    isNaN(alphay) || 
    isNaN(alphax) || 
    isNaN(Longueur) ||            
    isNaN(Profondeur) ||
    Rayon<=0 || 
    (alphax>0) ||
    (alphax>Math.PI) ||
    (alphay<0) ||
    (alphay>Math.PI) ||
    Longueur<=0 ||            
    Profondeur>0
    
) {

    //alert("Insérer une entrée valide");

    return

    } 

    
    const x0_2 = x0_1 + Longueur;
    const y0_2 = y0_1;


    const point1 = new THREE.Vector3(0, 0, 0);
    points_l.push(point1)
    const point2 = new THREE.Vector3(Longueur, 0, 0);
    points_l.push(point2);
    const geometry = new THREE.BufferGeometry().setFromPoints(points_l);
    
    line.rotation.y=alphaz;
    line.rotation.z=-alphay;
    line.rotation.x=-alphax;


    line.position.set(x0_1,Profondeur,y0_1);

    line.geometry.dispose();
    line.geometry=geometry;
  
    //scene.add(cone);
    var selectedValue=select.value;
   
    newItem.textContent = textinput;

    group_data_cube[index]={text_new_item,group_name,prevPosX,prevPosY,prevLength,prevDepth,prevRadius,prevRotZ,prevRotY,prevRotX,index};

    lines[index]=line;
    points_l=[];



    




/////////////////////////////////////////////STRUCTURE SPHERIQUE///////////////////////////////////////////



        }





       



    }


    ///////////////////////////////BOUTON STRUCTURE CUBIQUE//////////////////////////////////////////////////////////////////

lines=[];

////////////////////////////////BOUTON STRUCTURE SPHERIQUE//////////////////////////////////////////////////////////////
function ligneh(){

ligne_1 ('0','0','10','-0.5','8.0','0','0','0',Couleurlignes,0.0,0);

}

function lignev(){


ligne_1 ('0','0','10','-0.5','8.0','0','90','0',Couleurlignes,0.0,0);

}


//var segments=parseFloat(document.getElementById('segments').value);  
//var theta0=parseFloat(document.getElementById('theta0').value);  
//var theta1=parseFloat(document.getElementById('theta1').value); 
//var rayon_cercle=parseFloat(document.getElementById('rayon_cercle').value); 
//var x0_cercle=parseFloat(document.getElementById('x0_cercle').value); 
//var y0_cercle=parseFloat(document.getElementById('y0_cercle').value);
//var Profondeur_cercle=parseFloat(document.getElementById('Profondeur_cercle').value);


function arc() {



for (let i = 0; i < segments; i++) {
    
    //const theta = (theta0 / segments);
    //const x = x0_cercle + rayon_cercle * Math.cos(theta);
    //const y = y0_cercle + rayon_cercle * Math.sin(theta);
    const z = Profondeur_cercle;
    const theta=theta1-theta0;

    const theta_start =theta0+(i / segments) * theta;
    const theta_end = theta0+((i + 1) / segments) * theta;

    //const theta_start = (i / segments) * theta0;
    //const theta_end = ((i + 1) / segments) * theta0;

    // Point de départ du segment
    const x_start = (x0_cercle + rayon_cercle * Math.cos(theta_start*Math.PI/180));
    const y_start = (y0_cercle + rayon_cercle * Math.sin(theta_start*Math.PI/180));

    // Point d'arrivée du segment
    const x_end = x0_cercle + rayon_cercle * Math.cos(theta_end*Math.PI/180);
    const y_end = y0_cercle + rayon_cercle * Math.sin(theta_end*Math.PI/180);

    // Longueur du segment
    const longueur_segment = (Math.sqrt(Math.pow(x_end - x_start, 2) + Math.pow(y_end - y_start, 2)));

    // Inclinaison du segment (en radians)
    const inclinaison_segment = (Math.atan2(y_end - y_start, x_end - x_start))*180/Math.PI;

    ligne_1 (x_start.toFixed(2),y_start.toFixed(2),longueur_segment.toFixed(2),z.toFixed(2),'0.1',inclinaison_segment.toFixed(2),'0','0',Couleurlignes,0.0,0);

}






}



function maillage() {

    const x0 = x0_maillage;
    const y0 = y0_maillage;
    const longueurmaillage = longueur_maillage;
    const largeurmaillage = largeur_maillage;
    const z = Profondeur_maillage;
    const x_start = x0 - longueurmaillage/2;
    const x_end = x0 + longueurmaillage/2;
    const y_start = y0 - largeurmaillage/2;
    const y_end = y0 + largeurmaillage/2;
    const nombreconducteurshorizontaux = nombre_conducteurs_horizontaux;
    const nombreconducteursverticaux = nombre_conducteurs_verticaux;
    const taillemailles_x = longueurmaillage/(nombreconducteursverticaux-1);
    const taillemailles_y = largeurmaillage/(nombreconducteurshorizontaux-1);
    const rayonconducteursmaillage = rayon_conducteurs_maillage;
        
    for (let i = 0; i < nombreconducteurshorizontaux; i++) {
        
         const yi = y_start + i*taillemailles_y;
         const inclinaison_segment = 0;// (Math.atan2(y_end - y_start, x_end - x_start))*180/Math.PI;

         ligne_1 (x_start.toFixed(2),yi.toFixed(2),longueurmaillage.toFixed(2),z.toFixed(2),rayonconducteursmaillage.toFixed(2),inclinaison_segment.toFixed(2),'0','0',Couleurlignes,0.0,0);


    }


    for (let i = 0; i < nombreconducteursverticaux; i++) {
        
        const xi = x_start + i*taillemailles_x;
        const inclinaison_segment = 90;// (Math.atan2(y_end - y_start, x_end - x_start))*180/Math.PI;

        ligne_1 (xi.toFixed(2),y_start.toFixed(2),largeurmaillage.toFixed(2),z.toFixed(2),rayonconducteursmaillage.toFixed(2),inclinaison_segment.toFixed(2),'0','0',Couleurlignes,0.0,0);


   }


}




function ligne_1 (prevPosX,prevPosY,prevLength,prevDepth,prevRadius,prevRotZ,prevRotY,prevRotX,Couleurlignes, offset_g,index0) {
     
                   

hideInputFields();

removeAllTextMeshes();

points_l=[];

const itemList_line = document.getElementById('item-list');
itemList_line.addEventListener('click', handleItemClick);
const newItem_line = document.createElement('li');
document.addEventListener('keydown', handleKeyPress);
newItem_line.className = 'item';
itemList_line.appendChild(newItem_line);


if (shape_creation==true) {
                
    newItem_line.textContent=group_data_cube[index0].text_new_item;

}  else {
                                        
    newItem_line.textContent = 'Electrode de terre N° ' + (itemCounter_line+1);        
}


text_new_item=newItem_line.textContent;

const Diametre=parseFloat(prevRadius);
const x0_1 = parseFloat(prevPosX);
const y0_1 = parseFloat(prevPosY);
const Longueur=parseFloat(prevLength);
const Profondeur=parseFloat(prevDepth);
const alphaz=-parseFloat(prevRotZ)*Math.PI/180;
const alphay=parseFloat(prevRotY)*Math.PI/180;
const alphax=parseFloat(prevRotX)*Math.PI/180;


const x0_2 = x0_1 + Longueur;
const y0_2 = y0_1;


const point1 = new THREE.Vector3(0, 0, 0);
points_l.push(point1)
const point2 = new THREE.Vector3(Longueur, 0, 0);
points_l.push(point2);
const geometry = new THREE.BufferGeometry().setFromPoints(points_l);
const material = new THREE.LineBasicMaterial({ color: Couleurlignes });
const line = new THREE.Line(geometry, material);
line.rotation.y=alphaz;
line.rotation.z=-alphay;
line.rotation.x=-alphax;
line.position.set(x0_1,Profondeur,y0_1);

scene.add(line);
lines.push(line);

groups_data.push({newItem:newItem_line,group:line});

const index = groups_data.findIndex(group => group.newItem === newItem_line);

scene.add(line);

line.name='line';

group_name='line';

group_data_cube[index]={text_new_item,group_name,text_new_item,prevPosX,prevPosY,prevLength,prevDepth,prevRadius,prevRotZ,prevRotY,prevRotX,index};

lines[index]=line;

itemCounter_line++;

if (saveState_test === false && shape_creation === false) {

saveState();

}



}





///////////////////////////////CREATION STRUCTURE SPHERIQUE/////////////////////////////////////////////////////////////


    
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////SAVE SHAPES////////////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        

        selectedItem_2=null;

        

        function handleItemClick(event) {

            

        
        const selectedItem = event.target;

        const index = groups_data.findIndex(group => group.newItem === selectedItem);

        


        if (index>=0 && index < groups_data.length) {

            


        const {group,newItem}=groups_data[index];

              

        show_input_fields (selectedItem,group,index);



        renderer.domElement.addEventListener('click', function() {
        onMouseClick(index,selectedItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick

        });

        

       if (selectedItem.classList.contains('selected')) {

 
            show_input_fields (selectedItem,group,index);
           
                       
   
            
        } else {

        
            
        const selectedItems = document.querySelectorAll('.selected');

        selectedItems.forEach(item => {
        item.classList.remove('selected');
        });


            selectedItem.classList.add('selected');
           

        if (selectedItem_2 && selectedItem_2!==selectedItem) {


            

            selectedItem_2.classList.remove('selected');
            const index_2 = groups_data.findIndex(group => group.newItem === selectedItem_2);

            if (index_2==-1) {

                return


            }

            const {group,item}=groups_data[index_2];


            originalColor=Couleurlignes;
            lines[index_2].material.color.set(originalColor); // set original color

              
            
            

        }

        
            selectedItem_2=selectedItem;

            show_input_fields (selectedItem,group,index);



            for (let i = 0; i < lines.length; i++) {
            
                lines[i].material.color.set(Couleurlignes);
            }



            

            lines[index].material.color.set(Couleur_object); // Set highlight color

            index_x[0]=index;

        }

    }
    

    }
   


    function onMouseClick(index,selectedItem,group) {



        hideInputFields();

        const selectedItems = document.querySelectorAll('.selected');

        // Loop through each selected item and remove the "selected" class
        selectedItems.forEach(item => {
        item.classList.remove('selected');
       

        });
   
        if (lines[index]) {
            lines[index].material.color.set(Couleurlignes); // Set original color
        }

    
    if (intersect_object_line) {
                
        intersect_object_line.material.color.set(Couleur_object);

    }


   
    renderer.domElement.removeEventListener('click',onMouseClick);

    saveState();

    
            
}



        // Function to handle item selection and deletion
        function handleKeyPress(event) {
        const selectedItem = document.querySelector('#item-list .selected');

        if (event.key === 'Delete') {

        if (selectedItem) {

            document.getElementById('sceneContainer').removeEventListener('click', handleMouseClick);

            const index = groups_data.findIndex(group => group.newItem === selectedItem);
            const {group,newItem}=groups_data[index];

            scene.remove(lines[index])

            selectedItem.remove();

                 
            groups_data.splice(index, 1);
            group_data_cube.splice(index,1);
            lines.splice(index, 1);

            itemCounter_line=itemCounter_line-1;
           
            selectedItem_2=null;

            removeAllTextMeshes();
    
            hideInputFields();
  
            return selectedItem_2;



            

        }




        }

  
    
    
    
  }


  function delete_object () {
        const selectedItem = document.querySelector('#item-list .selected');


           if (selectedItem) {

            document.getElementById('sceneContainer').removeEventListener('click', handleMouseClick);

            const index = groups_data.findIndex(group => group.newItem === selectedItem);
            const {group,newItem}=groups_data[index];

            scene.remove(lines[index])

            selectedItem.remove();
                
            groups_data.splice(index, 1);
            group_data_cube.splice(index,1);
            lines.splice(index, 1);


            scene.remove(line);


            itemCounter_line=itemCounter_line-1;

            selectedItem_2=null;

            saveState();

            removeAllTextMeshes();

            hideInputFields();

            return selectedItem_2;





        }



  
    }


  counter_regle=false;
  objects_raycastes=[];

  function handleMouseClick(event) {

        
    //const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector3();
    const mouse1 = new THREE.Vector3();
    var rect = event.target.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left)/renderer.domElement.clientWidth) * 2 - 1;
    mouse1.x=((event.clientX - rect.left));
    mouse.y = -((event.clientY - rect.top)/renderer.domElement.clientHeight) * 2 + 1;
    mouse1.y=-((event.clientY - rect.top));
    mouse.z=0.5;
    mouse1.z=0.;
   
    mouse.unproject(camera);

    const raycaster = new THREE.Raycaster();
    raycaster.set(camera.position, mouse.sub(camera.position).normalize());
    //raycaster.setFromCamera(mouse, camera);

    const objectsToCheck = lines.concat(floor);

    // Find intersection point with scene objects
    const intersects = raycaster.intersectObjects(objectsToCheck);
    
    if (intersects.length > 0) {
        // Calculate distance from camera position to intersection point
        var intersectionPoint = intersects[0].point;
        selectedObject=intersects[0].object;

        const index = groups_data.findIndex(item => item.group === selectedObject);

        if (index!==-1) {


        const {group,newItem}=groups_data[index]; 

        for (let i = 0; i < lines.length; i++) {

            lines[i].material.color.set(Couleurlignes);
        }

        lines[index].material.color.set(Couleur_object); // Set highlight color
   
        intersectionPoint.x=parseFloat(group_data_cube[index].prevPosX);
        intersectionPoint.z=parseFloat(group_data_cube[index].prevPosY);
        intersectionPoint.y=parseFloat(group_data_cube[index].prevPosZ);

        } 

        index_test=index;


    }


      if (!startPoint) {
                startPoint = intersectionPoint;

                
            if (selectedObject.name=='floor') {

                floor_1=1;
                
            }

            objects_raycastes.push(selectedObject);

            index_test_v[0]=index_test;

            points_m.push(startPoint);


            } else {
                // If startPoint is set, set endPoint and measure distance
                endPoint = intersectionPoint;

                objects_raycastes.push(selectedObject);

                

                index_test_v[1]=index_test;

                points_m.push(endPoint);

                if (index_test_v[0]===-1 && index_test_v[1]===-1) {

                    points_m = [];

                } else if (index_test_v[0]===-1 && index_test_v[1]!==-1) {

                    points_m[0].x=points_m[1].x;
                    points_m[0].y=0;
                    points_m[0].z=points_m[1].z;

                } else if (index_test_v[1]===-1 && index_test_v[0]!==-1) {

                    points_m[1].x=points_m[0].x;
                    points_m[1].y=0;
                    points_m[1].z=points_m[0].z;

                }

                

                createLine();

                objects_raycastes=[];

                // Reset startPoint and endPoint for the next measurement
                startPoint = null;
                endPoint = null;
                
                points_m = [];

                
            }




    
  

}


 

  



        animate();



        ///////////////////////////////////////////////////SELECTION BUTTOM//////////////////////////////////////////////////////////////////////

        function selection () {
            document.getElementById('sceneContainer').addEventListener('click', selection_object);

        }

        

        selectedObject_2=null;

        index_x=[];
        //line_selected=0;
        intersect_object_line=null;

        function selection_object () {

            


            

            
            if (selectedObject_2 || intersect_object_line) {

            
                selectedObject_2=null;
                intersect_object_line=null;

                document.getElementById('sceneContainer').removeEventListener('click', selection_object);


            return;

            }


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0*0.5) / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0*0.5) / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);


        const intersects = raycaster.intersectObjects(lines);

            if (intersects.length>0) {

                
            const intersect_object=intersects[0].object;

        if (intersect_object.name=='line') {

            selectedObject_2=intersect_object;

            selectedObject_2.material.color.set(Couleur_object); // Set highlight color

            const index = groups_data.findIndex(item => item.group === selectedObject_2);
               
            const {group, newItem}=groups_data[index];

            newItem.classList.add('selected');

            //hideInputFields();

            renderer.domElement.addEventListener('click', function() {
            onMouseClick(index,newItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick
            });
            
            index_x[0]=index;

            show_input_fields (newItem,group,index);

            } 

    


       

        }

        

    };




shape_duplicate=false;







/////////////////////////////////////PROGRAMME PRINCIPAL/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






textMesh=null;

function addResult(x, y, z,label) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                const textGeometry = new THREE.TextGeometry(label, {
                    font: font,
                    size: 2.5,
                    height: 0.3
                }); 
                const textMaterial = new THREE.MeshBasicMaterial({ color: couleur_resultats });

                if (!textMesh) {
                    // Si textMesh n'existe pas, on le crée
                    textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(x, z, y);
                    textMesh.rotation.x = -Math.PI / 2;
                    scene.add(textMesh);
                } else {
                    // Si textMesh existe déjà, on met à jour sa géométrie et ses propriétés
                    textMesh.geometry.dispose(); // Libère l'ancienne géométrie
                    textMesh.geometry = textGeometry; // Remplace la géométrie par la nouvelle
                    textMesh.position.set(x, z, y);
                    textMesh.rotation.x = -Math.PI / 2;
                }
            });
        }


     

        function calculateCenter() {
    let sumX = 0, sumY = 0, sumZ = 0;
    const n = points.length;

    points.forEach(point => {
        sumX += point.x;
        sumY += point.y;
        sumZ += point.z;
    });

    const centerX = sumX / n;
    const centerY = sumY / n;
    const centerZ = sumZ / n;

    const center = new THREE.Vector3(centerX, centerY, centerZ);

        }

        function removeresults() {


            
            

            //for (let i = lines.length-1; i >=0; i--) {

            //    scene.remove(lines[i]);

            //    const selectedItem=groups_data[i].newItem;                         
            //    newItem.remove();
            //}
            removeAllTextMeshes()

            //group_data_cube=[];
            //groups_data=[];
            //lines=[];
            //itemCounter_line=0;

            //document.getElementById('results').disabled = false;
            //document.getElementById('results').enabled = false;
            //document.getElementById('results').classList.remove('disabled');
            //document.getElementById('results').classList.remove('enabled');

        }

let circle=null;
let area=0;
let Rayon_geometrique=0;


document.getElementById('print-results').disabled = true;
document.getElementById('print-results').classList.add('disabled');

selectedObject=null;

function drag() {
    
   
    // Inside the drag function, set up the event listener
    document.getElementById('sceneContainer').addEventListener('click', handleMouseClick_drag);
}

    function handleMouseClick_drag() {

    
        if (selectedObject) {

            selectedObject=null;

            document.getElementById('sceneContainer').removeEventListener('click',handleMouseClick_drag);
 
            return
   
           
        }

        
        


        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        //const moveMouse=new THREE.Vector2()

        mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0.5) / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0.5) / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(lines);
        
    
        if (intersects.length>0) {

        var intersect_object=intersects[0].object;


        selectedObject=intersects[0].object;

        
        const index = groups_data.findIndex(item => item.group === selectedObject);

        lines[index].material.color.set(Couleur_object); // Set highlight color
        
        const {group, newItem}=groups_data[index];



        newItem.classList.add('selected');

        index_x[0]=index;

        hideInputFields();

        renderer.domElement.addEventListener('click', function() {
        onMouseClick(index,newItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick
        });

              

        show_input_fields (newItem,group,index);



    }


    }  


    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    //const moveMouse=new THREE.Vector2()
    const moveMouse=new THREE.Vector2();
    const intersection = new THREE.Vector3();

    selectedObject=null;
    
    document.getElementById('sceneContainer').addEventListener('mousemove',function() {      ///////// Listen to mouse move ////////////////////////////

    mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0*0.5) / window.innerWidth) * 2 - 1;
    mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0*0.5) / window.innerHeight) * 2 + 1;

    // Update raycaster
    raycaster.setFromCamera(mouse, camera);

    if (selectedObject) {
        

        //controls.enabled = false;

        raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), intersection); 
        var xx=intersection.x.toFixed(2).toString();
        var yy=intersection.z.toFixed(2).toString();
        group_data_cube[index_x[0]].prevPosX=xx;
        group_data_cube[index_x[0]].prevPosY=yy;
        const {group, newItem}=groups_data[index_x[0]];

        show_input_fields (newItem,group,index_x[0]);

        
        
    }



    });///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function removeAllTextMeshes() {

    if (textMesh) {

        scene.remove(textMesh);
        textMesh=null;
    }
}    



const maxUndoRedoStackSize = 20;
let undoStack = [];
let redoStack = [];
let saveState_test = false;
document.getElementById('previous').classList.add('disabled');
document.getElementById('next').classList.add('disabled');
document.getElementById('previous').disabled = true;
document.getElementById('next').disabled = true;

previousState = {
    group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
    nomprojet: nomprojet || null,
    nomredacteur: nomredacteur || null,
    nomsociete: nomsociete || null,
    Couleur_scene: Couleur_scene || null,
    Couleur_object: Couleur_object || null,
    couleur_resultats: couleur_resultats || null,
    Couleurlignes: Couleurlignes || null,
    rho:rho || null

}




function saveState () {


    document.getElementById('previous').classList.remove('disabled','enabled');
    document.getElementById('previous').disabled = false;
    document.getElementById('next').classList.remove('disabled','enabled');
    document.getElementById('next').classList.add('disabled');
    document.getElementById('next').disabled = true;


    const currentState = {
        group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
        nomprojet: nomprojet || null,
        nomredacteur: nomredacteur || null,
        nomsociete: nomsociete || null,
        Couleur_scene: Couleur_scene || null,
        Couleur_object: Couleur_object || null,
        couleur_resultats: couleur_resultats || null,
        Couleurlignes: Couleurlignes || null,
        rho:rho || null

    }






    // Vérifier si l'état actuel est différent de l'état précédent
    if ((!_.isEqual(previousState, currentState) && saveState_test === false)) {

        if (undoStack.length >= maxUndoRedoStackSize) {
            undoStack.shift(); // Supprimez l'état le plus ancien
        }

        // Ajouter l'état précédent à la pile des undo




        undoStack.push(JSON.stringify(previousState));  
        


        redoStack = [];

        redoStack.push(JSON.stringify(currentState));  

       



        //const differences = findDifferences(previousState, currentState);
        //console.log('différences',differences);

        // Mettre à jour l'état précédent avec l'état actuel
        previousState = currentState;

        removeresults();

        if (fileName) {

            save();

        }







        

    }


}


function next() {

    saveState_test = !saveState_test;

    if (redoStack.length > 2) {

        const nextState = redoStack.pop();
        undoStack.push(nextState);

        // Parse and restore the next state
        const restoredState = JSON.parse(redoStack[redoStack.length-1]);

        restoreState(restoredState);

        document.getElementById('previous').classList.remove('disabled','enabled');
        //document.getElementById('next').classList.add('disabled');
        document.getElementById('previous').disabled = false;

        //console.log(undoStack.length,redoStack.length);




    } else if (redoStack.length === 2) {

        const nextState = redoStack.pop();
        undoStack.push(nextState);

        // Parse and restore the next state
        const restoredState = JSON.parse(redoStack[redoStack.length-1]);

        restoreState(restoredState);

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').classList.add('disabled');
        document.getElementById('next').disabled = true;
        //undoStack.pop();

        document.getElementById('previous').classList.remove('disabled','enabled');
        //document.getElementById('next').classList.add('disabled');
        document.getElementById('previous').disabled = false;

        //console.log(undoStack.length,redoStack.length);

    }

    saveState_test = !saveState_test;
}

function previous() {

    saveState_test = !saveState_test;


    if (undoStack.length > 1) {


        const lastState = undoStack.pop();
        redoStack.push(lastState);

        // Parse and restore the previous state
        const restoredState = JSON.parse(lastState);
        
        restoreState(restoredState);

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').disabled = false;

        //console.log(undoStack.length,redoStack.length);

 

    } else if (undoStack.length === 1) {

        const lastState = undoStack.pop();
        redoStack.push(lastState);

        // Parse and restore the previous state
        const restoredState = JSON.parse(lastState);
        
        restoreState(restoredState);


        document.getElementById('previous').classList.remove('disabled','enabled');
        document.getElementById('previous').classList.add('disabled');
        document.getElementById('previous').disabled = true;

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').disabled = false;

        //console.log(undoStack.length,redoStack.length);


    }




    saveState_test = !saveState_test;
}

function restoreState(state) {

    console.log(undoStack.length)

    clearScene();
    selectedItem_2=null;

    removeresults();

    

   
    group_data_cube = state.group_data_cube || [];
    nomprojet=state.nomprojet;
    nomredacteur=state.nomredacteur;
    nomsociete=state.nomsociete;
    rho=state.rho;
    Couleur_scene=state.Couleur_scene;
    Couleur_object=state.Couleur_object;
    couleur_resultats=state.couleur_resultats;
    Couleurlignes=state.Couleurlignes;


    previousState = {
        group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
        nomprojet: nomprojet || null,
        nomredacteur: nomredacteur || null,
        nomsociete: nomsociete || null,
        Couleur_scene: Couleur_scene || null,
        Couleur_object: Couleur_object || null,
        couleur_resultats: couleur_resultats || null,
        Couleurlignes: Couleurlignes || null,
        rho:rho || null
    };



    document.getElementById('nom_projet').value=nomprojet;
    document.getElementById('nom_redacteur').value=nomredacteur;
    document.getElementById('nom_societe').value=nomsociete;
    document.getElementById('resistivite').value=rho.toFixed(2);
    document.getElementById('Couleur_scene').value=Couleur_scene;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene
    document.getElementById('Couleur_object').value=Couleur_object;
    document.getElementById('Couleur_lignes').value=Couleurlignes;
    document.getElementById('Couleur_resultats').value=couleur_resultats;


        
    // Clear and recreate scene elements
    //clearScene(); // Custom function to remove all elements from the scene
    displayShapes(); // Custom function to add all elements back based on the restored state
}








var RT=10.0;   
var R;

async function programme_principal() {

    if (lines.length===0) {

        var message_box = "Absence de lignes dans le modèle élaboré !";
        Swal.fire({
            html: message_box,
            icon: "warning",
            customClass: {
            icon: 'custom-icon'
            }
        });

    // alert('Absence de structures !');

    return


    }

    var points_e=[];
    var points=[];
    var linedata=[];
    var rayons=[];
 

    document.getElementById('print-results').disabled = false;
    document.getElementById('print-results').classList.remove('disabled');
    document.getElementById('print-results').classList.add('enabled');


    removeAllTextMeshes();



    for (let i = 0; i < group_data_cube.length; i++) {

        points_ee=[];

        const Longueur = parseFloat(group_data_cube[i].prevLength);
        const Nombre_points=Longueur/longueur_e;
        if (Number.isInteger(Nombre_points)) {

            nombre_elements = Nombre_points;

                
        } else {

           nombre_elements = Math.floor(Nombre_points)+1;
        }
        
        const longueur_elementaire=Longueur/nombre_elements;
        linedata.push(longueur_elementaire);
        const Rayon=parseFloat(group_data_cube[i].prevRadius)*1E-3/2;
        rayons.push(Rayon);
        
        for (let j = 0; j < nombre_elements; j++) {

            const Longueur_j = parseFloat(group_data_cube[i].prevLength);
            const x0=parseFloat(group_data_cube[i].prevPosX);
            const y0=parseFloat(group_data_cube[i].prevPosY);
            const z0=parseFloat(group_data_cube[i].prevDepth);
            const alphaY=parseFloat(group_data_cube[i].prevRotY)*Math.PI/180;
            const alphaZ=parseFloat(group_data_cube[i].prevRotZ)*Math.PI/180;
            const alphaX=parseFloat(group_data_cube[i].prevRotX)*Math.PI/180;
            
            

            const x0_e=longueur_elementaire/2+j*longueur_elementaire;

            const point_eee = {
            x: x0_e * Math.cos(alphaY) * Math.cos(alphaZ)+x0,
            y: x0_e * Math.cos(alphaY) * Math.sin(alphaZ)+y0,
            z: -x0_e * Math.sin(alphaY)+z0,
            xi: x0_e * Math.cos(alphaY) * Math.cos(alphaZ)+x0,
            yi: x0_e * Math.cos(alphaY) * Math.sin(alphaZ)+y0,
            zi: -x0_e * Math.sin(alphaY)-z0,
            x0:(x0_e+0*longueur_elementaire/2) * Math.cos(alphaY) * Math.cos(alphaZ)+
            Rayon*(Math.cos(alphaX) * Math.sin(alphaY) * Math.cos(alphaZ)+Math.sin(alphaZ) * Math.sin(alphaX))+x0,
            y0:(x0_e+0*longueur_elementaire/2) * Math.cos(alphaY) * Math.sin(alphaZ)+
            Rayon*(Math.cos(alphaX) * Math.sin(alphaY) * Math.sin(alphaZ)-Math.cos(alphaZ) * Math.sin(alphaX))+y0,
            z0:-(x0_e+0*longueur_elementaire/2) * Math.sin(alphaY)+Rayon*Math.cos(alphaY)*Math.cos(alphaX)+z0,
            x1: 0*x0 * Math.cos(alphaY) * Math.cos(alphaZ)+x0,
            y1: 0*x0 * Math.cos(alphaY) * Math.sin(alphaZ)+y0,
            z1: -0*x0 * Math.sin(alphaY)+z0,
            x2: Longueur_j * Math.cos(alphaY) * Math.cos(alphaZ)+x0,
            y2: Longueur_j * Math.cos(alphaY) * Math.sin(alphaZ)+y0,
            z2: -Longueur_j * Math.sin(alphaY)+z0,
            
            };

            const point = {
            x: x0_e * Math.cos(alphaY) * Math.cos(alphaZ)+x0,
            y: x0_e * Math.cos(alphaY) * Math.sin(alphaZ)+y0,
            z: -x0_e * Math.sin(alphaY)+z0,
            }
            
            points_ee.push(point_eee);
            points.push(point);
            


        }      

        points_e.push(points_ee);

    }


    var Z = Array.from({ length: group_data_cube.length+1 }, () => Array(group_data_cube.length+1).fill(0));

    C = new Array(group_data_cube.length+1).fill(0);
    C[group_data_cube.length]=1;
    var distances=[];

    const response = await fetch('/calcul_MATRIX_Z_IMPEDANCE', {
    method: 'POST',
    headers: {
    'Content-Type': 'application/json'
    },
    body: JSON.stringify({Z,rho,points_e,group_data_cube})
    });
 
    // Attend la réponse du serveur
    const result = await response.json();

    Z = result.Z;
    






    
    try {

            B=math.inv(Z);
        } catch (error) {

           // if (lines.length===0) {

            var message_box = "Le programme a été interrompu en raison d'une erreur dans la construction des lignes du modèle. Veuillez vérifier s'il y a des lignes qui se chevauchent !";
            Swal.fire({
                html: message_box,
                icon: "warning",
                customClass: {
                icon: 'custom-icon'
                }
            });

            // alert('Absence de structures !');

            return


           // }



           // alert("Le programme a été interrompu en raison d'une erreur dans la construction des lignes du modèle. Veuillez vérifier s'il y a des lignes qui se chevauchent.");
           // return
    }

    I = math.multiply(B, C);




    let sumX = 0, sumY = 0, sumZ = 0;
    const n = points.length;

    points.forEach(point => {
        sumX += point.x;
        sumY += point.y;
        sumZ += point.z;
    });

    const centerX = sumX / n;
    const centerY = sumY / n;
    const centerZ = sumZ / n;

    R=I[points_e.length];

    label='IMPEDANCE DE TERRE: '+R.toFixed(2)+' Ohm';

    addResult(centerX, centerY,5,label);

    if (R<RT) {
        document.getElementById('results').disabled = false;
        document.getElementById('results').classList.remove('disabled');
        document.getElementById('results').classList.add('enabled');
    } else {
        document.getElementById('results').disabled = true;
        document.getElementById('results').classList.add('disabled');
    }



   

};



function new_file() {

    window.open('IMPEDANCE DE TERRE VERSION FINALE 23 08 24 15 55 SERVEUR.html', '_blank');
}


let fileHandle;



// Save function
async function save() {
    const data = {
        nomprojet,
        nomredacteur,
        nomsociete,
        rho,
        group_data_cube,
        lines,
        mission_rt:'rt',
        camera_position,
        Couleur_scene,
        Couleur_object,
        couleur_resultats,
        Couleurlignes,
        groups_data
    };

    const jsonData = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonData], { type: 'application/json' });

    try {
        if (!fileHandle) {
            // If no file handle, ask the user to pick a file and save for the first time
            fileHandle = await showSaveFilePicker({
                suggestedName: fileName || 'RT_Calcul_Prise_de_Terre.json',
                types: [{
                    description: 'JSON Files',
                    accept: { 'application/json': ['.json'] },
                }],
            });

            fileName = fileHandle.name; // Store the new file name if a new file is picked
        }

        // Create a writable stream and write the blob to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(blob);
        await writableStream.close();
        //alert('Fichier enregistré avec succès.');
    } catch (err) {
        if (err.name === 'AbortError') {
            //console.warn('Ouverture du fichier a été abandonnée.');
        } else {
            //console.error('Erreur de lecture du fichier:', err);
        }
    }
}

// Save As function
async function save_as() {
    const data = {
        nomprojet,
        nomredacteur,
        nomsociete,
        rho,
        group_data_cube,
        lines,
        mission_rt:'rt',
        camera_position,
        Couleur_scene,
        Couleur_object,
        couleur_resultats,
        Couleurlignes,
        groups_data
    };

    const jsonData = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonData], { type: 'application/json' });

    if (window.showSaveFilePicker) {
        // Use File System Access API if available
        try {

            const suggestedName = fileName || 'RT_Calcul_Prise_de_Terre.json'; // Use stored fileName or default
            // Open a file picker to select the file to save
            fileHandle = await showSaveFilePicker({
                suggestedName: suggestedName,
                types: [{
                    description: 'JSON Files',
                    accept: { 'application/json': ['.json'] },
                }],
            });

            fileName = fileHandle.name; // Store the file name

            // Create a writable stream and write the blob to the file
            const writableStream = await fileHandle.createWritable();
            await writableStream.write(blob);
            await writableStream.close();
            
            //alert('Fichier enregistré avec succès.');
        } catch (err) {
            if (err.name === 'AbortError') {
                //console.warn('Ouverture du fichier a été abandonnée.');
            } else {
                //console.error('Erreur de lecture du fichier:', err);
            }
        }
    } else {
        // Fallback for browsers without File System Access API
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'calcul_prise_de_terre.json';
        a.click();
        URL.revokeObjectURL(url);
    }
}


let fileName;

document.getElementById('openShapesButton').addEventListener('click', async(event) => {
    
    try {
        // Open file picker and get the file handle
        [fileHandle] = await window.showOpenFilePicker({
            types: [{
                description: 'JSON Files',
                accept: { 'application/json': ['.json'] },
            }],
        });


    fileName = fileHandle.name; // Store the file name

    const file = await fileHandle.getFile(); // Get the file object from the file handle

    const reader = new FileReader();
    reader.onload = function(e) {

    try {
    const data = JSON.parse(e.target.result);

    const prefixeAttendu = 'RT_'

    if (!data.mission_rt || (!file.name.startsWith(prefixeAttendu))) {

        alert('Fichier invalide');

        return


    }

    


    clearScene();
    
    undoStack = [];
    redoStack = [];
    saveState_test = false;
    document.getElementById('next').classList.remove('disabled','enabled');
    document.getElementById('next').classList.add('disabled');
    document.getElementById('next').disabled = true;

    document.getElementById('previous').classList.remove('disabled','enabled');
    document.getElementById('previous').classList.add('disabled');
    document.getElementById('previous').disabled = true;


    // Replace the existing arrays with the loaded data
    group_data_cube = data.group_data_cube || [];
    
    groups_data = data.groups_data || [];
    lines = data.lines || [];
    nomprojet=data.nomprojet;
    nomredacteur=data.nomredacteur;
    nomsociete=data.nomsociete;
    rho=data.rho;
    camera_position=data.camera_position;
    Couleur_scene=data.Couleur_scene;
    Couleur_object=data.Couleur_object;
    couleur_resultats=data.couleur_resultats;
    Couleurlignes=data.Couleurlignes;

    document.getElementById('nom_projet').value=nomprojet;
    document.getElementById('nom_redacteur').value=nomredacteur;
    document.getElementById('nom_societe').value=nomsociete;
    document.getElementById('nom_societe').value=nomsociete;
    document.getElementById('resistivite').value=rho.toFixed(2);
    document.getElementById('Couleur_scene').value=Couleur_scene;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene
    document.getElementById('Couleur_object').value=Couleur_object;
    document.getElementById('Couleur_lignes').value=Couleurlignes;
    document.getElementById('Couleur_resultats').value=couleur_resultats;
    document.getElementById('camera-position').value=camera_position.toFixed(0),
    camera.position.set(camera_position, camera_position, camera_position);
    camera.lookAt(0, 0, 0);
    controls.update();

    previousState = {
    group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
    nomprojet: nomprojet || null,
    nomredacteur: nomredacteur || null,
    nomsociete: nomsociete || null,
    Couleur_scene: Couleur_scene || null,
    Couleur_object: Couleur_object || null,
    couleur_resultats: couleur_resultats || null,
    Couleurlignes: Couleurlignes || null,
    rho:rho || null

    }


    // Update the display with the new data
    displayShapes();

    
 
    } catch (error) {
        
       alert('Fichier invalide');
       return;

    }

    };

    reader.onerror = function() {
        alert('Erreur de lecture du fichier');
    };




    reader.readAsText(file);

    

    } catch (error) {


                
    //console.error('Erreur lors de l\'ouverture du fichier:', error);
    //alert('Erreur lors de l\'ouverture du fichier.');
    }

});



var shape_creation = false;



function displayShapes() {

    groups_data = [];
    lines =[];
    document.getElementById('label-list').innerHTML = '';
    document.getElementById('item-list').innerHTML = '';

    shape_creation = !shape_creation;

    for (let o = 0; o <= group_data_cube.length - 1; o++) {

        ligne_1 (group_data_cube[o].prevPosX,group_data_cube[o].prevPosY,group_data_cube[o].prevLength,group_data_cube[o].prevDepth,group_data_cube[o].prevRadius,group_data_cube[o].prevRotZ,group_data_cube[o].prevRotY,group_data_cube[o].prevRotX,Couleurlignes, 0,o)
                    
    }
   
    shape_creation = !shape_creation;
}

function clearScene() {


    // Clear the arrays

    removeresults();
  
        
    for (let i = 0; i < lines.length; i++) {

        
        //scene.remove(lines[0]);
        const { group, newItem } = groups_data[i];
        newItem.remove();



    }

    lines.forEach(line => {
        scene.remove(line); // Supprime l'élément `line` de la scène
    });
    
    group_data_cube = [];
    groups_data = [];
    lines = [];
    selectedItem_2 = null;
    selectedObject_2=null;
    itemCounter_line = 0;
    

}



























        
    </script>
</body>
</html>
