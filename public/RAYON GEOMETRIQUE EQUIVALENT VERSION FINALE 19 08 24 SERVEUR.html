<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcul du rayon géométrique équivalent </title>

    <style>

       body {
            
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #dddddd; /* Set background color to light gray */
            overflow: hidden; /* Prevent scrolling */
        } 
 
        .container {
 

            border: 0px solid #ffffff; /* Set background color to light gray */
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling */
            background-color: #dddddd; /* Set background color to light gray */
            
        }

        #sceneContainer {
            flex: 1; /* Take the remaining space */
            width: 83vw;
            height: 91.5vh;
            background-color: #ffffff; /* Set background color to light gray */
            overflow: hidden; /* Ensure no overflow */
            float: right;
            display: flex; /* Flexbox to center content */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            border: 1px solid #ffffff;
            border-radius:10px;
        }

        #item-list {
            list-style-type: none;
            padding: 10px;
            margin: 5px;
            margin-left: 10px; /* Ajouter une marge à gauche */
            width: 16%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 460px; /* Maximum height of the container */
            overflow: auto; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            
        }



        #label-list {
        margin-top: 10px; /* Espace entre item-list et label-list */
        bottom: 0;
        left: 5px;
        margin-top: 5px; /* Add some margin at the top for spacing */
        margin-left: 10px; /* Ajouter une marge à gauche */

        width: 16%;
        padding: 10px;   
        max-height: 400px; /* Maximum height of the container */
        overflow: auto; /* Enable vertical scroll if content overflows */
        background-color: #dddddd; /* Set background color to light gray */
        border: 1px solid #ffffff;
        border-radius:10px;
        }



     

        .select_field {

        background-color: cornsilk;
        color:blue;
        width:250px;
        font-size:14px;
        border: 1px solid #ccc; /* Thin border */

        }

        #button-container {
                    list-style-type: none;
                    padding: 10px;
                    margin: 5px;
                    margin-left: 10px; /* Ajouter une marge à gauche */
                    width: auto;
                    margin-top: 5px; /* Add some margin at the top for spacing */
                    max-height: 50px; /* Maximum height of the container */
                    overflow: auto; /* Enable vertical scroll if content overflows */
                    background-color: #dddddd; /* Set background color to light gray */
                    border: 1px solid #ffffff;
                    border-radius:10px;
                    
                }

        #buttons {
            
            margin: 0px;
            
            position:relative
            
           
        }


        .item {
        background-color: #9797978e;
        padding: 5px;
        margin-bottom: 5px;
        border-radius: 15px;
        cursor: pointer;
        text-align: center;

        }

        .item:hover {
            background-color: rgba(213, 216, 47,0.3); /* Semi-transparent yellow overlay */
        }


    /* Style the labels */
    .label-list {
    list-style-type: none;
    padding: 0;
    margin: 5px;
    color: white;

    
    }

    
    .label {
            color: red; /* Change to red for visibility */
            font-size: 40px; /* Increase size for visibility */
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.7); /* Light background */
            padding: 5px; /* Increase padding */
            border-radius: 3px;
        }


    

    .label-list select {
    list-style-type: none;
    padding: 0;
    margin: 5px;
    color: white
    }

    #data-container {

        padding: 10px;
        margin: 5px;
        margin-left: 10px; /* Ajouter une marge à gauche */
        width: 14%;
        margin-top: 5px; /* Add some margin at the top for spacing */
        max-height: 100px; /* Maximum height of the container */
        overflow: auto; /* Enable vertical scroll if content overflows */
        background-color: #dddddd; /* Set background color to light gray */
        border: 1px solid #ffffff;
        border-radius:10px;
            
    }

    .label_input_field {
        font-size:16px;
    }
       
    
    .selected {

        background-color: #d5d82f;
    }

    .general-data-input {
        width:200px;
        height:20px;
        padding:0px;
        font-Size: 14px;
        color:blue;
        border:1px solid #dddddd;
        background-Color:cornsilk;
    }

    .custom-button {
            background-size: cover;
            background-position: center;
            width: 38px;
            height: 38px;
            border: 1px solid #000000;
            cursor: pointer;
    }

    .custom-button-1 {
            background-image: url("photos/nouveau_fichier.jpg");

        }

    .custom-button-2 {
            background-image: url("photos/open_file_arf.jpg");

        }       

    .custom-button-3 {
            background-image: url("photos/save.jpg");

        }
    


    .custom-button-4 {
            background-image: url("photos/save_as.jpg");

        }

         .custom-button-5 {
            background-image: url("photos/print_definitions.jpg");

        }

        .custom-button-6 {
            background-image: url("photos/noeud.jpg");

        }

        .custom-button-7 {
            background-image: url("photos/line.jpg");

        }

        .custom-button-8 {
            background-image: url("photos/delete.jpg");

        }

        .custom-button-9 {
            background-image: url("photos/run_t.jpg");

        }

        .custom-button-10 {
            background-image: url("photos/cut.jpg");

        }


        .custom-button-12 {
            background-image: url("photos/isometric_view_2.jpg");
  
        }

        .custom-button-13 {
            background-image: url("photos/top_2.jpg");

        }

        .custom-button-14 {
            background-image: url("photos/front_2.jpg");

        }

        .custom-button-15 {
            background-image: url("photos/back_2.jpg");

        }

        .custom-button-16 {
            background-image: url("photos/left_2.jpg");

        }

        .custom-button-17 {
            background-image: url("photos/right_2.jpg");

        }

        .custom-button-18 {
            background-image: url("photos/selection.jpg");

        }

        .custom-button-19 {
            background-image: url("photos/zoom_in.jpg");

        }

        .custom-button-20 {
            background-image: url("photos/zoom_out.jpg");

        }

        .custom-button-21 {
            background-image: url("photos/run-2.jpg");

        }

        .custom-button-21.disabled {
            background-image: url("photos/run_disable.jpg");

        }

        .custom-button-22 {
            background-image: url("photos/run-3.jpg");
   
        }

        .custom-button-23 {
            background-image: url("photos/drag_xy.jpg");

        } 

        .custom-button-24 {
            background-image: url("photos/settings.jpg");

        } 

        .custom-button-25 {
            background-image: url("photos/form.jpg");

        }

        .custom-button-26 {
            background-image: url("photos/results.jpg");

            
        }
        

        .custom-button-26.enabled {
            background-image: url("photos/results_p.jpg");

            
        }

        .custom-button-26.disabled {
            background-image: url("photos/results_n.jpg");

            
        }

        .custom-button-27 {
            background-image: url("photos/previous.jpg");
  
        }

        .custom-button-27.disabled {
            background-image: url("photos/previous_disabled.jpg");
  
        }

        .custom-button-27.enabled {
            background-image: url("photos/previous.jpg");
  
        }

        .custom-button-28 {
            background-image: url("photos/next.jpg");

        }

        .custom-button-28.disabled {
            background-image: url("photos/next_disabled.jpg");

        }

        .custom-button-28.enabled {
            background-image: url("photos/next.jpg");

        }



        .popup_settings {
            position: fixed;
            top: 60px;
            right: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 400px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;

            
        }

        .popup_form {
            position: fixed;
            top: 60px;
            left: 0;

            background-color: rgb(201, 201, 201);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 500px; /* Set the width of the popup */
            height: auto; /* Set the height of the popup */
            display: none;
            box-sizing: border-box; /* Include padding in width and height */
            overflow: none; /* Add scroll if content overflows */

            align-items: center;

            
        }

        /* Styles for the title */
        .popup-title {
            margin: -20px -20px 20px;
            padding: 10px 20px;
            background-color:#000000;
            color: white;
            font-size: 15px;
            text-align: left;

        }

        .overlay {
                position: fixed;
                top: 5%;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255,0); /* Fully transparent */
                display: none;
                z-index: 999;
        }

        .color-picker-container {
            display: flex;
            justify-content: space-between; /* Pushes the label to the left and the input to the right */
            align-items: center; /* Vertically aligns both the label and the input */
            width: 100%; /* Ensure the container takes the full width of its parent */
        }

        .color-picker-container label {
            margin-right: 10px; /* Optional: Add some space between the label and input */
        }

        #data-container {

            padding: 10px;
            margin: 5px;
            margin-left: 10px; /* Ajouter une marge à gauche */
            width: 16%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 100px; /* Maximum height of the container */
            overflow: auto; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;


        }




              #data-container-settings {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: space-between; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
               
            
        }

        #data-container-settings-button {

            padding: 10px;

            width: 100%;
            margin-top: 5px; /* Add some margin at the top for spacing */
            max-height: 200px; /* Maximum height of the container */
            overflow: none; /* Enable vertical scroll if content overflows */
            background-color: #dddddd; /* Set background color to light gray */
            border: 1px solid #ffffff;
            border-radius:10px;
            display: flex;
            justify-content: center; /* Aligns label to the left and input to the right */
            align-items: center; /* Vertically centers both label and input */
        

        }

        .general-data-input {

            width:250px;
            height:20px;
            padding:0px;
            font-Size: 14px;
            color:blue;
            border:1px solid #dddddd;
            background-Color:cornsilk;

        }

        .general-data-input-settings {

            width:300px;
            height:20px;
            padding:0px;
            font-Size: 14px;
            color:blue;
            border:1px solid #dddddd;
            background-Color:cornsilk;

        }

        .custom-icon {
            font-size: 10px; /* Taille réduite de l'icône */
        }

 




    </style>

</head>
<body>

   

    <div id="button-container">
        
            <!-- Buttons will be added here -->
            <button class="custom-button custom-button-25"  title="Données générales" id="form"> </button> 
            <button class="custom-button custom-button-1" title="Nouveau fichier" onclick="new_file()"> </button>
            <button class="custom-button custom-button-2" title="Ouvrir un fichier" id="openShapesButton"> </button>
            <input type="file" id="openShapes" style="display: none;">
            <input type="file" id="ImportShapes" style="display: none;">
            <button class="custom-button custom-button-3" title="Enregistrer" id="save" onclick="save()"> </button>
            <button class="custom-button custom-button-4" title="Enregistrer sous" id="save_as" onclick="save_as()"> </button>
            <button class="custom-button custom-button-27" title="précédent" id="previous" onclick="previous()"> </button>
            <button class="custom-button custom-button-28" title="suivant" id="next" onclick="next()"> </button>
            <button class="custom-button custom-button-5" title="Afficher les résultats" id="print-results" onclick="print_results()"> </button>
            <button class="custom-button custom-button-6" title="Créer un noeud" id="sphere" onclick="structure_spherique()"> </button>
            <button class="custom-button custom-button-8" title="retirer tous les éléments de la scene" id="delete" onclick="removeresults()"> </button>
            <button class="custom-button custom-button-9"  title="Lancer le calcul" id="run" onclick="programme_principal()"> </button>
            <button class="custom-button custom-button-26"  title="Conformité de la prise de terre - Rouge: Non conforme - Vert: Conforme" id="results" onclick=""> </button>
            <button class="custom-button custom-button-10"   title="supprimer un object" onclick="delete_object()"> </button>
            <button class="custom-button custom-button-12"  title="vue isommétrique" onclick="isometric_view ()"> </button>
            <button class="custom-button custom-button-13"  title="vue de dessus" onclick="top_view ()"> </button>
            <button class="custom-button custom-button-14"  title="vue de face" onclick="front_view ()"> </button>
            <button class="custom-button custom-button-15"  title="vue arrière" onclick="back_view ()"> </button>
            <button class="custom-button custom-button-16"  title="vue de gauche" onclick="left_view ()"> </button>
            <button class="custom-button custom-button-17"  title="vue de droite" onclick="right_view ()"> </button>
            <button class="custom-button custom-button-23"  title="déplacer un object dans le sens horizontal" id="dragObjectButton" onclick="drag()"> </button>
            <button class="custom-button custom-button-18"   title="selectionner l'object" id="SelectObjectButton" onclick="selection ()"> </button>
            <button class="custom-button custom-button-19"  title="zoom avant" onclick="zoom_in ()"> </button>
            <button class="custom-button custom-button-20"  title="zoom arrière" onclick="zoom_out ()"> </button>
            <button class="custom-button custom-button-21"  title="" id="updateresults"> </button>
            <button class="custom-button custom-button-24"  title="Paramètres" id="settings"> </button>
        
    </div>

 
    <div class="container" id="sceneContainer">

        <div class="overlay" id="overlay-settings"></div>
    
        <div class="popup_settings" id="popup-settings">

            <div class="popup-title">Paramètres</div>
           

            <div class="container" id="data-container-settings">
        
                <label for="camera-position" class="label_input_field">Position de la caméra (m) :</label>
               <input type="range" style="width: 100px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="camera-position" min="50" step="1" max="300" value="100">
                <span id="camera-position-value">100</span>
        
            </div>

  

            <div class="container" id="data-container-settings">
                <label for="taille-noeuds" class="label_input_field">Taille des noeuds (m) :</label>
                <input type="range" id="taille-noeuds" min="0.01" max="2.0" step="0.01" value="0.5"> 
                <span id="taille-noeuds-value">0.5</span>
            </div>

 

            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_scene" class="label_input_field">Couleur de la scene :</label>
                    <input type="color" id="Couleur_scene" style="width: 50px; height: 20px;" value="#000000">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_object" class="label_input_field">Couleur de la selection :</label>
                    <input type="color" id="Couleur_object" style="width: 50px; height: 20px;" value="#00ff00">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">

                <div class="color-picker-container">
                    <label for="Couleur_lignes" class="label_input_field">Couleur des lignes :</label>
                    <input type="color" id="Couleur_lignes" style="width: 50px; height: 20px;" value="#ff00ff">
                </div>
        
            </div>


            <div class="container" id="data-container-settings">
        
                
                <div class="color-picker-container">
                    <label for="Couleur_resultats" class="label_input_field">Couleur des résultats :</label>
                    <input type="color" id="Couleur_resultats" style="width: 50px; height: 20px;" value="#fae500">
                </div>

        
            </div>

         


        </div>


        <div class="overlay" id="overlay-form"></div>
    
        <div class="popup_form" id="popup-form">

            <div class="popup-title">Données générales</div>
           
            <div class="container" id="data-container-settings"> 
                <label for="nom_projet" class="label_input_field">Nom du projet:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_projet" style="color: blue;" value="Nom du projet">
            </div>

            <div class="container" id="data-container-settings"> 
                <label for="nom_redacteur" class="label_input_field">Nom du rédacteur:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_redacteur" style="color: blue;" value="Nom et prénom">
            </div>

            <div class="container" id="data-container-settings"> 
                <label for="nom_societe" class="label_input_field">Nom de la société:</label>
                <input type="text" style="width: 250px; height: 20px; background-color:cornsilk;color: blue; border: 1px solid #ccc" id="nom_societe" style="color: blue;" value="Nom de la société">
            </div>
 

        </div>

      
    </div>


      
    </div>


    <div class="container" id="data-container">

        <div>
            <label class="label_input_field" id="niveau_protection">Niveau de protection requis</label>
        </div>

        <div>

            <select class="select_field" id="niveau-protection"  onclick="">

                <option value="1">Niveau I</option>
                <option value="2">Niveau II</option>
                <option value="3">Niveau III</option>
                <option value="4">Niveau IV</option>

        
            </select>

        </div>

      
    </div>

    <div class="container" id="data-container">

        <label for="resistivite" class="label_input_field">Résistivité du sol (Ohm.m)</label>
        <!-- Input element for the second pair -->
                   
        <div>
        <input type="text" class="general-data-input" id="resistivite"  value="500">
        </div>

    </div>


    <div class="container" id="item-list">
    
    </div>


    <div class="container" id="label-list">
               
    </div>


<!-- Include the necessary dependencies -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.js"></script>
<script src="OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<script>

///////////////////////POPUP SETTINGS /////////////////////////////////////////
const popup_settings = document.getElementById('popup-settings');
const overlay_settings = document.getElementById('overlay-settings');
let setting_apparition = false;

// Fonction pour afficher la popup
function showPopup_settings() {
    popup_settings.style.display = "block";
    overlay_settings.style.display = "block";
    setting_apparition = true;
}

// Fonction pour masquer la popup
function hidePopup_settings() {
    popup_settings.style.display = "none";
    overlay_settings.style.display = "none";
    setting_apparition = false;
}

// Gestionnaire pour ouvrir la popup
document.getElementById('settings').addEventListener('click', showPopup_settings);

// Gestionnaire global pour détecter les clics hors de la popup
document.addEventListener('click', function(event) {
    if (setting_apparition && !popup_settings.contains(event.target) && event.target.id !== 'settings') {
        hidePopup_settings();
    }
});

// Gestionnaire pour fermer avec la touche Escape
document.addEventListener('keydown', function(event) {
    if (event.key === "Escape" && setting_apparition) {
        hidePopup_settings();
    }
});

//////////////////////////////////////////////////////////

///////////////////////POPUP FORM /////////////////////////////////////////
const popup_form = document.getElementById('popup-form');
const overlay_form = document.getElementById('overlay-form');
let form_apparition = false;

// Fonction pour afficher la popup
function showPopup_form() {
    popup_form.style.display = "block";
    overlay_form.style.display = "block";
    form_apparition = true;
}

// Fonction pour masquer la popup
function hidePopup_form() {
    popup_form.style.display = "none";
    overlay_form.style.display = "none";
    form_apparition = false;
}

// Gestionnaire pour ouvrir la popup
document.getElementById('form').addEventListener('click', showPopup_form);

// Gestionnaire global pour détecter les clics hors de la popup
document.addEventListener('click', function(event) {
    if (form_apparition && !popup_form.contains(event.target) && event.target.id !== 'form') {
        hidePopup_form();
    }
});

// Gestionnaire pour fermer avec la touche Escape
document.addEventListener('keydown', function(event) {
    if (event.key === "Escape" && form_apparition) {
        hidePopup_form();
    }
});

//////////////////////////////////////////////////////////


var Couleur_scene='#000000';

document.getElementById('Couleur_scene').addEventListener('change', function() {
    Couleur_scene = document.getElementById('Couleur_scene').value;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene

    saveState();
});


var couleur_object='#00ff00';

document.getElementById('Couleur_object').addEventListener('change', function() {
    couleur_object = document.getElementById('Couleur_object').value;

    saveState();
});

var Couleurlignes='#ff00ff';

document.getElementById('Couleur_lignes').addEventListener('change', function() {
    Couleurlignes = document.getElementById('Couleur_lignes').value;

    groups_data.forEach((item,index) => {
        if (item.group && item.group.name === 'sphere') {

            newMaterial = new THREE.MeshPhongMaterial({color: Couleurlignes });

        // Dispose of the old geometry to free memory
        item.group.material.dispose();
        
        // Assign the new geometry to the sphere
        item.group.material = newMaterial;

            
        }
    });

    lines.forEach(line => {
        line.material.color.set(Couleurlignes); 

    });




    saveState();
});

var couleur_resultats='#fae500';

document.getElementById('Couleur_resultats').addEventListener('change', function() {
    couleur_resultats = document.getElementById('Couleur_resultats').value;

    saveState();
});


var Rayon=0.5;
var taille_noeuds_s='0.5';

document.getElementById('taille-noeuds').addEventListener('input', function() {
    document.getElementById('taille-noeuds-value').textContent = this.value;
    taille_noeuds_s=this.value;

    Rayon  = parseFloat(this.value);

    // Function to update the radius of all spheres in groups_data

    groups_data.forEach(item => {
        if (item.group && item.group.name === 'sphere') {

            const newGeometry = new THREE.SphereGeometry(Rayon, 32, 32);
        // Dispose of the old geometry to free memory
        item.group.geometry.dispose();
        
        // Assign the new geometry to the sphere
        item.group.geometry = newGeometry;
            
        }
    });

    saveState();



});

var camera_position=100;
var camera_position_s='100';

document.getElementById('camera-position').addEventListener("input", function() {
    document.getElementById('camera-position-value').textContent = this.value;
    camera_position_s = this.value;
    camera_position = parseFloat(this.value);
    camera.position.set(camera_position, camera_position, camera_position);
    camera.lookAt(0, 0, 0);
    controls.update();

   // saveState();
});


nomprojet='Projet N°';

document.getElementById('nom_projet').addEventListener('change',function() {

nomprojet = document.getElementById('nom_projet').value;

saveState();

});

nomredacteur='Nom Prénom';

document.getElementById('nom_redacteur').addEventListener('change',function() {

nomredacteur = document.getElementById('nom_redacteur').value;

saveState();

});


nomsociete='Nom de la société';
document.getElementById('nom_societe').addEventListener('change',function() {

nomsociete = document.getElementById('nom_societe').value;

saveState();

});


function print_results() {

    const newWindow = window.open('aaaaa', '_blank');

    const newDoc = newWindow.document;

    // Obtenir la date actuelle
    const currentDate = new Date();
    const formattedDate = currentDate.toLocaleDateString('fr-FR', {
        Année: 'numeric',
        Mois: 'long',
        Jour: 'numeric'
    });


    const versionlogicielle='ELP-RG-02-08-01A';
    const normeReference='NF EN 62305-3';

    const niveau_protection = document.getElementById('niveau-protection').value;

    const rho = document.getElementById('resistivite').value;

    var statut;
    var color_statut;

    if (Rayon_geometrique>=le) {

        statut='OUI';
        color_statut='#006400';


    } else {

        statut='NON';
        color_statut='#ff0000';

    }

    if (rho>3000) {
        comment='(Valeur obtenue par extrapolation)';
    } else {
        comment='';
    }

    const html = `
    <html>
    <head>
        <title>CALCUL DE LA DISTANCE DE SEPARATION - ${''} </title>
            <style>
            @media print {
                    @page {
                        margin-left: 1cm;
                        margin-right: 1cm;
                        margin-top: 2cm;
                        margin-bottom: 1cm;
                    }
                    body {
                        margin: 0;
                    }
                    .page-number:after {
                        content: counter(page);
                    }
                    .page-number {
                        position: fixed;
                        bottom: 0;
                        width: 100%;
                        text-align: center;
                    }
                }

                
                /* Optional: Additional CSS styles for the output window */
            </style>
    </head>
    <body>

    <h3 style="text-decoration: underline; text-align: center;">DONNEES DE SORTIE LOGICIELLE</h3>
    <p style="text-align: center">Version logicielle: <span style="color: blue;">${versionlogicielle}</span></p>
    <p style="text-align: center">Nom du projet: <span style="color: blue;">${nomprojet}</span></p>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">DONNEES GENERALES</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <p>Date: <span style="color: blue;">${formattedDate}</span></p>
    <p>Norme de référence: <span style="color: blue;">${normeReference}</span></p>
    <p>Nom et prénom du rédacteur: <span style="color: blue;">${nomredacteur}</span></p>
    <p>Nom de la société: <span style="color: blue;">${nomsociete}</span></p>
    <p>Niveau de protection requis: <span style="color: blue;">${niveau_protection}</span></p>
    <p>Résistivité du sol: <span style="color: blue;">${rho} Ohm.m</span></p>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">NOEUDS SAISIS</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>

    <div id="enterednodes-data-container"></div>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">CONDUCTEURS SAISIS</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>

    <div id="enteredlines-data-container"></div>

    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>
    <h4 style="margin: 0px 0;">RESULTATS DE CALCUL</h4>  
    <p style="margin: 0;">--------------------------------------------------------------------------------------------------------------</p>

    <div id="results-container"></div>


    
    </body>
    </html>
    `;


    newDoc.open();

    newDoc.write(html);
    newDoc.close();

    newWindow.onload = function () {

    const enterednodesdatacontainer = newDoc.getElementById('enterednodes-data-container');
    const enteredlinesdatacontainer = newDoc.getElementById('enteredlines-data-container');
    const resultscontainer = newDoc.getElementById('results-container');



    for (let i = 0; i < group_data_cube_float.length; i++) {

            enterednodesdatacontainer.innerHTML += `
            <h4 style="text-decoration: underline;">${group_data_cube[i].text_new_item}</h4>
            <div style="display: flex; flex-wrap: wrap;">
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (X0): <span style="color: blue;">${group_data_cube_float[i].x0_1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Y0): <span style="color: blue;">${group_data_cube_float[i].y0_1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Z0): <span style="color: blue;">${group_data_cube_float[i].z0_1} m</span></p>

            </div>


        `;
   

    }

    

    for (let i = 0; i < points_lines.length; i++) {

            x1=points_lines[i].x;
            y1=points_lines[i].y;
            z1=points_lines[i].z;

            if (i===points_lines.length-1) {

                x2=points_lines[0].x;
                y2=points_lines[0].y;
                z2=points_lines[0].z;

            } else {

                x2=points_lines[i+1].x;
                y2=points_lines[i+1].y;
                z2=points_lines[i+1].z;


            }
 
            enteredlinesdatacontainer.innerHTML += `
            <h4 style="text-decoration: underline;">Ligne N°${i+1}</h4>

            
            <div style="display: flex; flex-wrap: wrap;">
            <p style="margin: 0 10px 0 0; padding: 0;">Point de départ: <span style="color: blue;"></span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (X0): <span style="color: blue;">${x1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Y0): <span style="color: blue;">${y1} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Z0): <span style="color: blue;">${z1} m</span></p>
            </div>

            <div style="display: flex; flex-wrap: wrap;">
            <p style="margin: 0 10px 0 0; padding: 0;">Point d'arrivée: <span style="color: blue;"></span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (X0): <span style="color: blue;">${x2} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Y0): <span style="color: blue;">${y2} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Centre (Z0): <span style="color: blue;">${z2} m</span></p>
            </div>


        `;
    

    }

    



    resultscontainer.innerHTML += `
            
            
            <p style="margin: 0 10px 0 0; padding: 0;">Surface occupée par la prise de terre: <span style="color: blue;">${area.toFixed(2)} m<sup>2</sup></span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Rayon géométrique équivalent: <span style="color: blue;">${Rayon_geometrique.toFixed(2)} m</span></p>
            <p style="margin: 0 10px 0 0; padding: 0;">Longueur minimale d'électrodes requise par la norme: <span style="color: blue;">${le.toFixed(2)} m ${comment} </span></p>
            <p style="margin: 0 10px 0 0; padding: 0;font-weight: bold;">Prise de terre conforme (OUI/NON): <span style="color: ${color_statut};">${statut}</span></p>


        `;


    
    newWindow.print();

    const tempWindow = window.open('', '_blank', 'width=1,height=1');
    tempWindow.blur(); // Perdre le focus de la fenêtre temporaire
    window.focus(); // Revenir à la fenêtre principale
    setTimeout(() => tempWindow.close(), 100); // Fermer la fenêtre temporaire


}

}





        /////////////////////////////////////////////////////////////////////


 

        var group_scene = new THREE.Group();
        groups_data=[];
        const originalColorsByGroup = new Map();
        inputdata=null;
        group_data_cube=[];
        group_data_cube_float=[];
        index=null;
        var points=null;

        let itemCounter_cube = 0;
        let itemCounter_f = 0;
        let itemCounter_cy = 0;
        let itemCounter_cyh = 0;
        let itemCounter_tsp = 0;
        let itemCounter_tcy = 0;
        let itemCounter_co = 0;
        let itemCounter_sp = 0;
        let itemCounter_pda = 0;
        let itemCounter_pts = 0;
        let itemCounter_ca = 0;
        var currentView = null;//'perspective';
        var currentView_1 =null; //'perspective';
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        //var rayon_p;
        var Nombre_points=100;
        var Rayon_p=20.;
        let initialFov
        let initialCameraPosition 
        let initialCameraRotation
        var snp=[];
        var test_snp=0;
        var sprites=[];


        
        
        //////////////////////////////INTITIALISE THE SCENE//////////////////////////////////////////////////////

        init();
        

        //var camera_position=50;

        function init() {
       
            scene = new THREE.Scene();
            camera_position=100.;
            camera_position_z=50.;
            currentView='perspective'
            camera = new THREE.PerspectiveCamera(75, window.innerWidth /window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(Couleur_scene, 1);
            
            camera.position.set(camera_position, camera_position, camera_position); // Default top view
            camera.lookAt(0, 0, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('sceneContainer').appendChild(renderer.domElement);

            initialFov = camera.fov;
            initialCameraPosition = camera.position.clone();
            initialCameraRotation=camera.rotation.clone();
        
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            controls.reset();
  

    }

    
    ///////////////////////////////ADDED FOR VIEWS//////////////////////////////////////////////////////////

        axes_creation ();
        light_interraction ();
        

        ////////////////////////////////////////AXES CREATION/////////////////////////////////////////////////////

    function axes_creation () {
 
        var xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(100, 0, 0) // direction of the X-axis
        ]);
        var xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
        group_scene.add(xAxis);
        scene.add(xAxis);
        xAxis.name = 'xAxis';

        // Create line for Y-axis
        var yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 100, 0) // direction of the Y-axis
        ]);
        var yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        var yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
        group_scene.add(yAxis);
        scene.add(yAxis);
        yAxis.name = 'yAxis';

        // Create line for Z-axis
        var zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 100) // direction of the Z-axis
        ]);
        var zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        var zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
        group_scene.add(zAxis);
        scene.add(zAxis);
        zAxis.name = 'zAxis';

    }
    
        //////////////////////////////////////////////////////////////////////////////////////////////////////////


        function light_interraction () {
        // Add ambient light
        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Add directional light
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        }



    ///////////////////////////////////////////////ANIMATE FUNCTION//////////////////////////////////////////
    function animate() {


        requestAnimationFrame(animate);
               
        renderer.render(scene, camera);

            
        controls.update(); // Update controls continuously

        controls.enabled=true;
          


    }


        function top_view() {



            //cameraZ = new THREE.OrthographicCamera(-size * aspect, size * aspect, size, -size, near, far);
            camera.position.set(0, camera_position, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }

                function front_view() {

            controls.reset();
          
            camera.position.set(0, 0, camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

  
        }


        function back_view() {

            controls.reset();
            
            camera.position.set(0, 0, -camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        function left_view() {

            controls.reset();
            
            camera.position.set(-camera_position, 0, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        function right_view() {
           
            controls.reset();
            camera.position.set(camera_position, 0, 0);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);

        }


        // Function to switch to front view
  
        function isometric_view() {
            controls.reset();
            camera.position.set(camera_position, camera_position, camera_position);
            camera.lookAt(0, 0, 0);
            scene.rotation.set(0, 0, 0); // Reset scene rotation
            renderer.render(scene, camera);
        }

        
         function zoom_in() {

            
            if (currentView==='perspective') {

  
            camera.fov -= 5; // Decrease the field of view to zoom in
            camera.updateProjectionMatrix(); // Update the camera's projection matrix

            } else {

                
            var aspect = window.innerWidth / window.innerHeight;
            var size = 5;
            var near = -10;
            var far = 10;
            var zoomFactor = +5;

            cameraX.left += zoomFactor * aspect;
            cameraX.right -= zoomFactor * aspect;
            cameraX.top -= zoomFactor;
            cameraX.bottom += zoomFactor;
            cameraX.updateProjectionMatrix();

            cameraXM.left += zoomFactor * aspect;
            cameraXM.right -= zoomFactor * aspect;
            cameraXM.top -= zoomFactor;
            cameraXM.bottom += zoomFactor;
            cameraXM.updateProjectionMatrix();

            cameraY.left += zoomFactor * aspect;
            cameraY.right -= zoomFactor * aspect;
            cameraY.top -= zoomFactor;
            cameraY.bottom += zoomFactor;
            cameraY.updateProjectionMatrix();

            cameraYM.left += zoomFactor * aspect;
            cameraYM.right -= zoomFactor * aspect;
            cameraYM.top -= zoomFactor;
            cameraYM.bottom += zoomFactor;
            cameraYM.updateProjectionMatrix();

            cameraZ.left += zoomFactor * aspect;
            cameraZ.right -= zoomFactor * aspect;
            cameraZ.top -= zoomFactor;
            cameraZ.bottom += zoomFactor;
            cameraZ.updateProjectionMatrix();

                // Similar adjustments for cameraY and cameraZ if need

                }



            }
        
        
        function zoom_out() {
            
            
            if (currentView==='perspective') {
  
            camera.fov += 5; // Decrease the field of view to zoom in
            camera.updateProjectionMatrix(); // Update the camera's projection matrix

            } else {
        
            var aspect = window.innerWidth / window.innerHeight;
            var size = 5;
            var near = -10;
            var far = 10;
            var zoomFactor = +5;

            cameraX.left -= zoomFactor * aspect;
            cameraX.right += zoomFactor * aspect;
            cameraX.top += zoomFactor;
            cameraX.bottom -= zoomFactor;
            cameraX.updateProjectionMatrix();

            cameraXM.left -= zoomFactor * aspect;
            cameraXM.right += zoomFactor * aspect;
            cameraXM.top += zoomFactor;
            cameraXM.bottom -= zoomFactor;
            cameraXM.updateProjectionMatrix();

            cameraY.left -= zoomFactor * aspect;
            cameraY.right += zoomFactor * aspect;
            cameraY.top += zoomFactor;
            cameraY.bottom -= zoomFactor;
            cameraY.updateProjectionMatrix();

            cameraYM.left -= zoomFactor * aspect;
            cameraYM.right += zoomFactor * aspect;
            cameraYM.top += zoomFactor;
            cameraYM.bottom -= zoomFactor;
            cameraYM.updateProjectionMatrix();

            cameraZ.left -= zoomFactor * aspect;
            cameraZ.right += zoomFactor * aspect;
            cameraZ.top += zoomFactor;
            cameraZ.bottom -= zoomFactor;
            cameraZ.updateProjectionMatrix();

        // Similar adjustments for cameraY and cameraZ if need

        }


        }

 
 

        sol()


        var floor;
       
   
        function sol() {
            
            var length_s=1000.0;
            var width_s=1000.0;
            var height_s=0.1;
            var x_s=0.0;
            var y_s=0.0;
            var z_s=-0.1;
            //var rotationAngle=0; //degré
            //var rotationAngle=rotationAngle*Math.PI/180;
            var cubeGeometry_s = new THREE.BoxGeometry(length_s,height_s,width_s);
            var cubeMaterial_s = new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 });
            floor = new THREE.Mesh(cubeGeometry_s, cubeMaterial_s);
            floor.position.set(x_s, z_s, y_s);
            floor.userData.id='floor'
            //floor.rotation.z=rotationAngle;

            group_scene.add(floor);
            
            scene.add(floor);

            renderer.render(scene, camera);

            //document.addEventListener('click', onClick, false);

            floor.name='floor';


        }

 
        let rho=500;

        document.getElementById('resistivite').addEventListener('change',function() {

            rho = parseFloat(document.getElementById('resistivite').value);
            niveau_protection=document.getElementById('niveau-protection').value

            if (rho<=0 || isNaN(rho)) {

                document.getElementById('resistivite').value='500';

                return

            } 

        if (niveau_protection==='1') {

            if (rho <= 500) {

                le=5.0;

            } else {

                le=((80-5)/(3000-500))*(rho-500)+5;
                
            }


        } else if (niveau_protection==="2") {

            if (rho <= 800) {

                le=5.0;

            } else {

                le=((15-5)/(1300-800))*(rho-800)+5;
                
            }


        } else {

            le=5.0;


        }

        saveState();

        });
 

        function hideInputFields() {

            
        var labelsInputContainer = document.getElementById('label-list');

        if (labelsInputContainer) {
        labelsInputContainer.innerHTML = ''; // Clear the container

        }


        }


        function show_input_fields (newItem,group,index){
           
        hideInputFields()
     
        
 


 

var labelsInputContainer = document.getElementById('label-list');
var select = document.createElement("select");
var select_2 = document.createElement("select");

// Create and append label and input fields for cube dimensions
var RenameLabelDiv = document.createElement('div');
var RenameLabel = document.createElement('label');
RenameLabel.textContent = 'Renommer:';
RenameLabel.style.display = 'block'; // Ensure label is on its own line
RenameLabelDiv.appendChild(RenameLabel);
var RenameInput = document.createElement('input');
RenameInput.type = 'text';
//widthInput.style.marginLeft = '150px';
RenameInput.placeholder = 'Nom de la structure';
RenameInput.value = group_data_cube[index].text_new_item;
//widthInput.style.marginLeft = '50px';
RenameInput.style.color = 'blue'; // Set text color to blue
RenameInput.style.display = 'block'; // Ensure label is on its own line
RenameInput.style.width = '200px'; // Set width
RenameInput.style.height = '20px'; // Set width
RenameInput.style.padding = '0px'; // Adjust padding to match select
RenameInput.style.border = '1px solid #ccc'; // Match border style
RenameInput.style.fontSize = '14px'; // Match font size
RenameInput.style.boxSizing = 'border-box'; // Include padding and border in the width
RenameInput.style.backgroundColor='cornsilk';
RenameInput.addEventListener('input', updateCubeDimensions);
RenameInput.addEventListener('input', saveState);
RenameLabelDiv.appendChild(RenameInput);
labelsInputContainer.appendChild(RenameLabelDiv);

// Create and append label and input fields for cube position
var xLabelDiv = document.createElement('div');
var xLabel = document.createElement('label');
xLabel.textContent = 'Origine X0 (m):';
xLabel.style.display = 'block'; // Ensure label is on its own line
xLabelDiv.appendChild(xLabel);
var xInput = document.createElement('input');
xInput.type = 'number';
xInput.placeholder = 'Entrer la valeur';
xInput.value =group_data_cube[index].prevPosX ;
xInput.style.color = 'blue'; // Set text color to blue
xInput.style.display = 'block'; // Ensure label is on its own line
xInput.style.width = '200px'; // Set width
xInput.style.height = '20px'; // Set width
xInput.style.padding = '0px'; // Adjust padding to match select
xInput.style.border = '1px solid #ccc'; // Match border style
xInput.style.fontSize = '14px'; // Match font size
xInput.style.boxSizing = 'border-box'; // Include padding and border in the width
xInput.style.backgroundColor='cornsilk';
xInput.addEventListener('input', updateCubeDimensions);
xInput.addEventListener('change', saveState);
//xInput.style.marginLeft = '50px';
xLabelDiv.appendChild(xInput);
labelsInputContainer.appendChild(xLabelDiv);

var yLabelDiv = document.createElement('div');
var yLabel = document.createElement('label');
yLabel.textContent = 'Origine Y0 (m):';
yLabel.style.display = 'block'; // Ensure label is on its own line
yLabelDiv.appendChild(yLabel);
var yInput = document.createElement('input');
yInput.type = 'number';
yInput.placeholder = 'Entrer la valeur';
yInput.value = group_data_cube[index].prevPosY;
yInput.style.color = 'blue'; // Set text color to blue
yInput.style.display = 'block'; // Ensure label is on its own line
yInput.style.width = '200px'; // Set width
yInput.style.height = '20px'; // Set width
yInput.style.padding = '0px'; // Adjust padding to match select
yInput.style.border = '1px solid #ccc'; // Match border style
yInput.style.fontSize = '14px'; // Match font size
yInput.style.boxSizing = 'border-box'; // Include padding and border in the width
yInput.style.backgroundColor='cornsilk';
yInput.addEventListener('input', updateCubeDimensions);
yInput.addEventListener('change', saveState);
//yInput.style.marginLeft = '50px';
yLabelDiv.appendChild(yInput);
labelsInputContainer.appendChild(yLabelDiv);

var zLabelDiv = document.createElement('div');
var zLabel = document.createElement('label');
zLabel.textContent = 'Origine Z0 (m):';
zLabel.style.display = 'block'; // Ensure label is on its own line
zLabelDiv.appendChild(zLabel);
var zInput = document.createElement('input');
zInput.type = 'number';
zInput.placeholder = 'Entrer la valeur';
zInput.value = group_data_cube[index].prevPosZ;
zInput.style.color = 'blue'; // Set text color to blue
zInput.style.display = 'block'; // Ensure label is on its own line
zInput.style.width = '200px'; // Set width
zInput.style.height = '20px'; // Set width
zInput.style.padding = '0px'; // Adjust padding to match select
zInput.style.border = '1px solid #ccc'; // Match border style
zInput.style.fontSize = '14px'; // Match font size
zInput.style.boxSizing = 'border-box'; // Include padding and border in the width
zInput.style.backgroundColor='cornsilk';
zInput.addEventListener('input', updateCubeDimensions);
zInput.addEventListener('change', saveState);
//zInput.style.marginLeft = '50px';
zLabelDiv.appendChild(zInput);
labelsInputContainer.appendChild(zLabelDiv);






        xInput.dispatchEvent(new Event('input'));
  

  


  
     
    function updateCubeDimensions() {

        

        test_snp=0;

        



        
       
        


///////////////////////////////////////////////////////STRUCTURE CONIQUE///////////////////////////////////////////////////

sphere=spheres[index];

textinput=document.getElementById('label-list').querySelectorAll('input')[0].value;
text_new_item=document.getElementById('label-list').querySelectorAll('input')[0].value;
x0_1 = parseFloat(document.getElementById('label-list').querySelectorAll('input')[1].value);
prevPosX=document.getElementById('label-list').querySelectorAll('input')[1].value
y0_1 = parseFloat(document.getElementById('label-list').querySelectorAll('input')[2].value);
prevPosY=document.getElementById('label-list').querySelectorAll('input')[2].value
z0_1 = parseFloat(document.getElementById('label-list').querySelectorAll('input')[3].value);
prevPosZ=document.getElementById('label-list').querySelectorAll('input')[3].value;



group_name='sphere';

if (Rayon<=0 ||
    textinput=='' ||
    isNaN(x0_1) ||
    isNaN(y0_1) ||                
    isNaN(z0_1) ||
    z0_1>=0
    
) {

    //alert("Insérer une entrée valide");

    return

    } 

    var sphereGeometry = new THREE.SphereGeometry(Rayon, 64, 64);
    sphere.position.set(x0_1, z0_1, y0_1);
    points_lines[index].x=x0_1;
    points_lines[index].y=y0_1;
    points_lines[index].z=z0_1;

    sphere.geometry.dispose();
    sphere.geometry=sphereGeometry
    //scene.add(cone);
    var selectedValue=select.value;
 
   
    newItem.textContent = textinput;

    group_data_cube[index]={text_new_item,prevPosX,prevPosY,prevPosZ,index};
    group_data_cube_float[index]={group_name,Rayon,x0_1,y0_1,z0_1};
    spheres[index]=sphere;

    drawLines();

    if (let_dynamic_results===true) {


        programme_principal();


    };

    




/////////////////////////////////////////////STRUCTURE SPHERIQUE///////////////////////////////////////////



        }





       



    }


    ///////////////////////////////BOUTON STRUCTURE CUBIQUE//////////////////////////////////////////////////////////////////

let points_lines = [];

////////////////////////////////BOUTON STRUCTURE SPHERIQUE//////////////////////////////////////////////////////////////
function structure_spherique(){

structure_spherique_1 ('0','0','-0.5',0.0, 0);

}

////////////////////////////////BOUTON STRUCTURE SPHERIQUE//////////////////////////////////////////////////////////////

///////////////////////////////CREATION STRUCTURE SPHERIQUE/////////////////////////////////////////////////////////////

spheres=[];

function structure_spherique_1 (prevPosX, prevPosY, prevPosZ, offset_g,index0) {

          

hideInputFields();


const itemList_sphere = document.getElementById('item-list');
itemList_sphere.addEventListener('click', handleItemClick);
const newItem_sphere = document.createElement('li');
document.addEventListener('keydown', handleKeyPress);
newItem_sphere.className = 'item';
itemList_sphere.appendChild(newItem_sphere);

if (shape_creation==true) {
                
    newItem_sphere.textContent=group_data_cube[index0].text_new_item;
}  else {
                                        
    newItem_sphere.textContent = 'Noeud N° ' + (itemCounter_sp+1);        
}


text_new_item=newItem_sphere.textContent;

//Rayon=parseFloat(prevRadius);
x0_1 = parseFloat(prevPosX);
y0_1 = parseFloat(prevPosY);
z0_1 = parseFloat(prevPosZ);

var sphereGeometry = new THREE.SphereGeometry(Rayon, 32, 32);
var sphereMaterial = new THREE.MeshPhongMaterial({ color: Couleurlignes });
var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphere.position.set(x0_1+offset_g, z0_1, y0_1+offset_g);

groups_data.push({newItem:newItem_sphere,group:sphere});

const index = groups_data.findIndex(group => group.newItem === newItem_sphere);


if (!shape_creation) {

if (index>0) {

    x0_1=group_data_cube_float[index-1].x0_1+5;
    y0_1=group_data_cube_float[index-1].y0_1+5;
    prevPosX=x0_1.toFixed(2);
    prevPosY=y0_1.toFixed(2);
    sphere.position.set(x0_1+offset_g, z0_1, y0_1+offset_g);

}

}

scene.add(sphere);

sphere.name='sphere';

group_name='sphere';

group_data_cube[index]={text_new_item,prevPosX,prevPosY,prevPosZ,index};
group_data_cube_float[index]={group_name,Rayon,x0_1,y0_1,z0_1};
spheres[index]=sphere;

const point_1 = new THREE.Vector3(x0_1, y0_1, z0_1);
points_lines.push(point_1);

drawLines();

 

itemCounter_sp++;

if (saveState_test === false && shape_creation === false) {

saveState();

}

}

points_l=[];
lines=[];

function drawLines() {

        if (lines.length>0) {


            lines.forEach(line => {
            scene.remove(line);
            lines=[];


        });

        }

        if (points_lines.length > 1) {

            

            


            for (let i = 1; i < group_data_cube.length; i++) {

                const x0=group_data_cube_float[i-1].x0_1;
                const y0=group_data_cube_float[i-1].y0_1;
                const z0=group_data_cube_float[i-1].z0_1;
                const x1=group_data_cube_float[i].x0_1;
                const y1=group_data_cube_float[i].y0_1;
                const z1=group_data_cube_float[i].z0_1;

                const point1 = new THREE.Vector3(x0, z0, y0);
                points_l.push(point1)
                const point2 = new THREE.Vector3(x1, z1, y1);
                points_l.push(point2);
                const geometry = new THREE.BufferGeometry().setFromPoints(points_l);
                const material = new THREE.LineBasicMaterial({ color: Couleurlignes });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);

                points_l=[];

            }

            if (group_data_cube.length>=3) {

                const x0=group_data_cube_float[0].x0_1;
                const y0=group_data_cube_float[0].y0_1;
                const z0=group_data_cube_float[0].z0_1;
                const x1=group_data_cube_float[group_data_cube_float.length-1].x0_1;
                const y1=group_data_cube_float[group_data_cube_float.length-1].y0_1;
                const z1=group_data_cube_float[group_data_cube_float.length-1].z0_1;

                const point1 = new THREE.Vector3(x0, z0, y0);
                points_l.push(point1)
                const point2 = new THREE.Vector3(x1, z1, y1);
                points_l.push(point2);
                const geometry = new THREE.BufferGeometry().setFromPoints(points_l);
                const material = new THREE.LineBasicMaterial({ color: Couleurlignes });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);


                points_l=[];


            }

        
    }


}




///////////////////////////////CREATION STRUCTURE SPHERIQUE/////////////////////////////////////////////////////////////


    
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////SAVE SHAPES////////////////////////////////////////////////////////////////////

save_index=0;
save_group_data_cube=[];
save_group_data_cube_float=[];




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        

        selectedItem_2=null;

        

        function handleItemClick(event) {
        const selectedItem = event.target;




        //const index=groups_data.findInex(group)
        const index = groups_data.findIndex(group => group.newItem === selectedItem);


        //const {group,newItem}=groups_data[index];


        if (index>=0 && index < groups_data.length) {

 
        
//        const A=group_data_cube[index];

        const {group,newItem}=groups_data[index];

      

        show_input_fields (selectedItem,group,index);



        renderer.domElement.addEventListener('click', function() {
        onMouseClick(index,selectedItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick
    });

        

       if (selectedItem.classList.contains('selected')) {
        //selectedItem.classList.add('selected');

 
            show_input_fields (selectedItem,group,index);
   
            
     } else {

        
        const selectedItems = document.querySelectorAll('.selected');

        selectedItems.forEach(item => {
        item.classList.remove('selected');
        });

            selectedItem.classList.add('selected');
           
            
        if (selectedItem_2 && selectedItem_2!==selectedItem) {


            selectedItem_2.classList.remove('selected');
            const index_2 = groups_data.findIndex(group => group.newItem === selectedItem_2);

            if (index_2==-1){

                return


            }
            const {group,item}=groups_data[index_2];


            spheres[index_2].material.color.set(Couleurlignes); // set original color
            

        }

            selectedItem_2=selectedItem;

            show_input_fields (selectedItem,group,index);

            for (let i = 0; i < spheres.length; i++) {

                spheres[i].material.color.set(Couleurlignes);
            }

            

            spheres[index].material.color.set(couleur_object); // Set highlight color

            index_x[0]=index;

        }

    }
    

    }
   


    function onMouseClick(index,selectedItem,group) {



        hideInputFields();

        const selectedItems = document.querySelectorAll('.selected');

        // Loop through each selected item and remove the "selected" class
        selectedItems.forEach(item => {
        item.classList.remove('selected');
       

        });

        spheres.forEach(sphere => {
        sphere.material.color.set(Couleurlignes); 
       

        });
   
        //if (spheres[index]) {
        //    spheres[index].material.color.set(Couleurlignes); // Set original color
        //}

        lines.forEach(line => {
        line.material.color.set(Couleurlignes); 

        });

    
    //if (intersect_object_line) {
                
    //    intersect_object_line.material.color.set(0x000000);

    //}


   
    renderer.domElement.removeEventListener('click',onMouseClick);


    saveState();

    
            
}



        // Function to handle item selection and deletion
        function handleKeyPress(event) {
        const selectedItem = document.querySelector('#item-list .selected');

        if (event.key === 'Delete') {

        if (selectedItem) {

            document.getElementById('sceneContainer').removeEventListener('click', handleMouseClick);

            const index = groups_data.findIndex(group => group.newItem === selectedItem);
            const {group,newItem}=groups_data[index];

            scene.remove(spheres[index])

            selectedItem.remove();

            //textMeshTRemove(group_data_cube_float[index].x0_1,group_data_cube_float[index].y0_1);
                 
            groups_data.splice(index, 1);
            group_data_cube.splice(index,1);
            group_data_cube_float.splice(index,1);
            spheres.splice(index, 1);
            points_lines.splice(index,1);

            drawLines();

            itemCounter_sp=itemCounter_sp-1;


           
            selectedItem_2=null;

            saveState();
    
            hideInputFields();
  
            return selectedItem_2;



            

        }




        }

  
    
    
    
  }


  function delete_object () {
        const selectedItem = document.querySelector('#item-list .selected');


           if (selectedItem) {

            document.getElementById('sceneContainer').removeEventListener('click', handleMouseClick);

            const index = groups_data.findIndex(group => group.newItem === selectedItem);
            const {group,newItem}=groups_data[index];

            scene.remove(spheres[index])

            selectedItem.remove();

            //textMeshTRemove(group_data_cube_float[index].x0_1,group_data_cube_float[index].y0_1);
                
            groups_data.splice(index, 1);
            group_data_cube.splice(index,1);
            group_data_cube_float.splice(index,1);
            spheres.splice(index, 1);
            points_lines.splice(index,1);

            drawLines();

            itemCounter_sp=itemCounter_sp-1;

            selectedItem_2=null;

            saveState();

            hideInputFields();

            return selectedItem_2;



        }

  
    }


  counter_regle=false;
  objects_raycastes=[];

  function handleMouseClick(event) {

        
    //const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector3();
    const mouse1 = new THREE.Vector3();
    var rect = event.target.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left)/renderer.domElement.clientWidth) * 2 - 1;
    mouse1.x=((event.clientX - rect.left));
    mouse.y = -((event.clientY - rect.top)/renderer.domElement.clientHeight) * 2 + 1;
    mouse1.y=-((event.clientY - rect.top));
    mouse.z=0.5;
    mouse1.z=0.;
   
    mouse.unproject(camera);

    const raycaster = new THREE.Raycaster();
    raycaster.set(camera.position, mouse.sub(camera.position).normalize());
    //raycaster.setFromCamera(mouse, camera);

    const objectsToCheck = spheres.concat(floor);

    // Find intersection point with scene objects
    const intersects = raycaster.intersectObjects(objectsToCheck);
    
    if (intersects.length > 0) {
        // Calculate distance from camera position to intersection point
        var intersectionPoint = intersects[0].point;
        selectedObject=intersects[0].object;

        const index = groups_data.findIndex(item => item.group === selectedObject);

        if (index!==-1) {


        const {group,newItem}=groups_data[index]; 

        for (let i = 0; i < spheres.length; i++) {

            spheres[i].material.color.set(Couleurlignes);
        }

        spheres[index].material.color.set(couleur_object); // Set highlight color
   
        intersectionPoint.x=group_data_cube_float[index].x0_1;
        intersectionPoint.z=group_data_cube_float[index].y0_1;
        intersectionPoint.y=group_data_cube_float[index].z0_1;

        } 

        index_test=index;


    }


      if (!startPoint) {
                startPoint = intersectionPoint;

                
            if (selectedObject.name=='floor') {

                floor_1=1;
                
            }

            objects_raycastes.push(selectedObject);

            index_test_v[0]=index_test;

            points_m.push(startPoint);


            } else {
                // If startPoint is set, set endPoint and measure distance
                endPoint = intersectionPoint;

                objects_raycastes.push(selectedObject);

                

                index_test_v[1]=index_test;

                points_m.push(endPoint);

                if (index_test_v[0]===-1 && index_test_v[1]===-1) {

                    points_m = [];

                } else if (index_test_v[0]===-1 && index_test_v[1]!==-1) {

                    points_m[0].x=points_m[1].x;
                    points_m[0].y=0;
                    points_m[0].z=points_m[1].z;

                } else if (index_test_v[1]===-1 && index_test_v[0]!==-1) {

                    points_m[1].x=points_m[0].x;
                    points_m[1].y=0;
                    points_m[1].z=points_m[0].z;

                }
              
                //createLine();

                objects_raycastes=[];

                // Reset startPoint and endPoint for the next measurement
                startPoint = null;
                endPoint = null;
                
                points_m = [];

                
            }




    
  

}


 

  



        animate();



        ///////////////////////////////////////////////////SELECTION BUTTOM//////////////////////////////////////////////////////////////////////

        function selection () {
            document.getElementById('sceneContainer').addEventListener('click', selection_object);

        }

        

        selectedObject_2=null;

        index_x=[];
        //line_selected=0;
        intersect_object_line=null;

        function selection_object () {

            


            

            
            if (selectedObject_2 || intersect_object_line) {

            
                selectedObject_2=null;
                intersect_object_line=null;

                document.getElementById('sceneContainer').removeEventListener('click', selection_object);


            return;

            }


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0*0.5) / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0*0.5) / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        //const objects_raycaster=[spheres,lines,floor];


        //groups_data.push({newItem:newItem_sphere,group:group_sphere});

        //const objectsToCheck = spheres.concat(floor,lines);


        const intersects = raycaster.intersectObjects(spheres);

            if (intersects.length>0) {

                
            const intersect_object=intersects[0].object;

        if (intersect_object.name=='sphere') {

            selectedObject_2=intersect_object;
            //selectedObject_2.parent.children.forEach(function(child) {
                selectedObject_2.material.color.set(couleur_object); // Set highlight color

            //});

            //if (intersect_object_line) {
                
            //    intersect_object_line.material.color.set(0x000000);

            //}

            const index = groups_data.findIndex(item => item.group === selectedObject_2);
               

            const {group, newItem}=groups_data[index];

            newItem.classList.add('selected');

            //hideInputFields();

            renderer.domElement.addEventListener('click', function() {
            onMouseClick(index,newItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick
            });
            
            index_x[0]=index;

            show_input_fields (newItem,group,index);

            } 

    


       

        }

        

    };

    function findSphereIndex(x0, y0, z0) {
        index = group_data_cube_float.findIndex(point => point.x0_1===x0 && point.y0_1 === y0 && point.z0_1 === z0)
        return index
    }



shape_duplicate=false;







/////////////////////////////////////PROGRAMME PRINCIPAL/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


var niveau_protection='1';

let le=5.0;

document.getElementById('niveau-protection').addEventListener('change', function() {
        niveau_protection = document.getElementById('niveau-protection').value;
        rho = parseFloat(document.getElementById('resistivite').value);

        if (this.value==="1") {

            if (rho <= 500) {

                le=5.0;

            } else {

                le=((80-5)/(3000-500))*(rho-500)+5;
                
            }


        } else if (this.value==="2") {

            if (rho <= 800) {

                le=5.0;

            } else {

                le=((15-5)/(1300-500))*(rho-800)+5;
                
            }


        } else {

            le=5.0;


        }

        saveState();


    });

  


updatebutton=document.getElementById('updateresults');

let let_dynamic_results=false;

updatebutton.addEventListener('click', function() {

    let_dynamic_results=!let_dynamic_results

    if (let_dynamic_results!==false) {

    var button = document.getElementById('updateresults');
            //button.classList.remove('disabled'); // Remove the 'disabled' class
            button.style.backgroundImage = "url('photos/run-3.jpg')"; // Reset background image
            button.title="Arrêter le calcul dynamique"

    } else {

        var button = document.getElementById('updateresults');
            //button.classList.remove('disabled'); // Remove the 'disabled' class
            button.style.backgroundImage = "url('photos/run-2.jpg')"; // Reset background image
            button.title="Lancer le calcul dynamique"


    }

 

});

textMesh=null;

function addResult(x, y, z,label) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                const textGeometry = new THREE.TextGeometry(label, {
                    font: font,
                    size: 2.5,
                    height: 0.3
                }); 
                const textMaterial = new THREE.MeshBasicMaterial({ color: couleur_resultats });

                if (!textMesh) {
                    // Si textMesh n'existe pas, on le crée
                    textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(x, z, y);
                    textMesh.rotation.x = -Math.PI / 2;
                    scene.add(textMesh);
                } else {
                    // Si textMesh existe déjà, on met à jour sa géométrie et ses propriétés
                    textMesh.geometry.dispose(); // Libère l'ancienne géométrie
                    textMesh.geometry = textGeometry; // Remplace la géométrie par la nouvelle
                    textMesh.position.set(x, z, y);
                    textMesh.rotation.x = -Math.PI / 2;
                }
            });
        }


     

        function calculateCenter() {
    let sumX = 0, sumY = 0, sumZ = 0;
    const n = points.length;

    points.forEach(point => {
        sumX += point.x;
        sumY += point.y;
        sumZ += point.z;
    });

    const centerX = sumX / n;
    const centerY = sumY / n;
    const centerZ = sumZ / n;

    const center = new THREE.Vector3(centerX, centerY, centerZ);

        }

        function removeresults() {


            if (circle) {

                scene.remove(circle);
                scene.remove(textMesh);
                scene.remove(circle);

            }

            a=0;

            document.getElementById('results').disabled = false;
            document.getElementById('results').enabled = false;
            document.getElementById('results').classList.remove('disabled');
            document.getElementById('results').classList.remove('enabled');

        }

let circle=null;
let area=0;
let Rayon_geometrique=0;


document.getElementById('print-results').disabled = true;
document.getElementById('print-results').classList.add('disabled');

selectedObject=null;

function drag() {

    removeresults();

    
   
    // Inside the drag function, set up the event listener
    document.getElementById('sceneContainer').addEventListener('click', handleMouseClick_drag);
}

    function handleMouseClick_drag() {

    
        if (selectedObject) {

            selectedObject=null;

            document.getElementById('sceneContainer').removeEventListener('click',handleMouseClick_drag);
 
            return
   
           
        }

        
        


        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        //const moveMouse=new THREE.Vector2()

        mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0.5) / window.innerWidth) * 2 - 1;
        mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0.5) / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(spheres);
        
    
        if (intersects.length>0) {

        var intersect_object=intersects[0].object;


        selectedObject=intersects[0].object;

        
        const index = groups_data.findIndex(item => item.group === selectedObject);

        spheres[index].material.color.set(couleur_object); // Set highlight color
        
        const {group, newItem}=groups_data[index];

        newItem.classList.add('selected');

        index_x[0]=index;

        hideInputFields();

        renderer.domElement.addEventListener('click', function() {
        onMouseClick(index,newItem,group,Couleurlignes); // Pass the index as an argument to handleItemClick
        });

              

        show_input_fields (newItem,group,index);



    }


    }  


    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    //const moveMouse=new THREE.Vector2()
    const moveMouse=new THREE.Vector2();
    const intersection = new THREE.Vector3();

    selectedObject=null;
    
    document.getElementById('sceneContainer').addEventListener('mousemove',function() {      ///////// Listen to mouse move ////////////////////////////

    mouse.x = ((event.clientX - renderer.domElement.offsetLeft + 0*0.5) / window.innerWidth) * 2 - 1;
    mouse.y = -((event.clientY - renderer.domElement.offsetTop + 0*0.5) / window.innerHeight) * 2 + 1;

    // Update raycaster
    raycaster.setFromCamera(mouse, camera);

    if (selectedObject) {
        

        //controls.enabled = false;

        raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), intersection); 
        var xx=intersection.x.toFixed(2).toString();
        var yy=intersection.z.toFixed(2).toString();
        group_data_cube[index_x[0]].prevPosX=xx;
        group_data_cube[index_x[0]].prevPosY=yy;
        const {group, newItem}=groups_data[index_x[0]];

        show_input_fields (newItem,group,index_x[0]);

        drawLines();

        
        
    }



    });///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



const maxUndoRedoStackSize = 20;
let undoStack = [];
let redoStack = [];
let saveState_test = false;
document.getElementById('previous').classList.add('disabled');
document.getElementById('next').classList.add('disabled');
document.getElementById('previous').disabled = true;
document.getElementById('next').disabled = true;

previousState = {
    group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
    group_data_cube_float : JSON.parse(JSON.stringify(group_data_cube_float || [])),
    //groups_data : JSON.parse(JSON.stringify(groups_data || [])),
    //spheres : JSON.parse(JSON.stringify(spheres || [])),
    nomprojet: nomprojet || null,
    nomredacteur: nomredacteur || null,
    nomsociete: nomsociete || null,
    niveau_protection: niveau_protection || null,
    rho: rho || null, // No need for JSON.parse(JSON.stringify()) for primitives
    le: le || null, // No need for JSON.parse(JSON.stringify()) for primitives
    Couleur_scene: Couleur_scene || null,
    couleur_object: couleur_object || null,
    couleur_resultats: couleur_resultats || null,
    Couleurlignes: Couleurlignes || null,
    Rayon: Rayon || null,
    taille_noeuds_s: taille_noeuds_s || null,

}





//undoStack.push(JSON.stringify(previousState));  

//function findDifferences(previousState, currentState) {
   // const modified = {};
    
    // Parcourir toutes les clés de l'état courant
   // for (const key in currentState) {
   //     if (!_.isEqual(previousState[key], currentState[key])) {
   //         modified[key] = {
   //             previous: previousState[key],
   //             current: currentState[key],
   //         };
  //      }
  //  }
  //  return modified;
//}

function saveState () {

    
    //removeresults();

    document.getElementById('previous').classList.remove('disabled','enabled');
    document.getElementById('previous').disabled = false;
    document.getElementById('next').classList.remove('disabled','enabled');
    document.getElementById('next').classList.add('disabled');
    document.getElementById('next').disabled = true;


    const currentState = {
        group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
        group_data_cube_float : JSON.parse(JSON.stringify(group_data_cube_float || [])),
        //groups_data : JSON.parse(JSON.stringify(groups_data || [])),
        //spheres : JSON.parse(JSON.stringify(spheres || [])),
        nomprojet: nomprojet || null,
        nomredacteur: nomredacteur || null,
        nomsociete: nomsociete || null,
        niveau_protection: niveau_protection || null,
        rho: rho || null, // No need for JSON.parse(JSON.stringify()) for primitives
        le: le || null, // No need for JSON.parse(JSON.stringify()) for primitives
        Couleur_scene: Couleur_scene || null,
        couleur_object: couleur_object || null,
        couleur_resultats: couleur_resultats || null,
        Couleurlignes: Couleurlignes || null,
        Rayon: Rayon || null,
        taille_noeuds_s: taille_noeuds_s || null,
    }

    // Vérifier si l'état actuel est différent de l'état précédent
    if ((!_.isEqual(previousState, currentState) && saveState_test === false)) {

        removeresults();

        if (undoStack.length >= maxUndoRedoStackSize) {
            undoStack.shift(); // Supprimez l'état le plus ancien
        }

        // Ajouter l'état précédent à la pile des undo




        undoStack.push(JSON.stringify(previousState));  
        


        redoStack = [];

        redoStack.push(JSON.stringify(currentState));  

        //const differences = findDifferences(previousState, currentState);
        //console.log('différences',differences);

        // Mettre à jour l'état précédent avec l'état actuel
        previousState = currentState;


        if (fileName) {

            save();

        }





        

    }


}


function next() {

    saveState_test = !saveState_test;

    if (redoStack.length > 2) {

        const nextState = redoStack.pop();
        undoStack.push(nextState);

        // Parse and restore the next state
        const restoredState = JSON.parse(redoStack[redoStack.length-1]);

        restoreState(restoredState);

        document.getElementById('previous').classList.remove('disabled','enabled');
        //document.getElementById('next').classList.add('disabled');
        document.getElementById('previous').disabled = false;

        //console.log(undoStack.length,redoStack.length);




    } else if (redoStack.length === 2) {

        const nextState = redoStack.pop();
        undoStack.push(nextState);

        // Parse and restore the next state
        const restoredState = JSON.parse(redoStack[redoStack.length-1]);

        restoreState(restoredState);

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').classList.add('disabled');
        document.getElementById('next').disabled = true;
        //undoStack.pop();

        document.getElementById('previous').classList.remove('disabled','enabled');
        //document.getElementById('next').classList.add('disabled');
        document.getElementById('previous').disabled = false;

        //console.log(undoStack.length,redoStack.length);

    }

    saveState_test = !saveState_test;
}

function previous() {

    saveState_test = !saveState_test;


    if (undoStack.length > 1) {


        const lastState = undoStack.pop();
        redoStack.push(lastState);

        // Parse and restore the previous state
        const restoredState = JSON.parse(lastState);
        
        restoreState(restoredState);

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').disabled = false;

        //console.log(undoStack.length,redoStack.length);

 

    } else if (undoStack.length === 1) {

        const lastState = undoStack.pop();
        redoStack.push(lastState);

        // Parse and restore the previous state
        const restoredState = JSON.parse(lastState);
        
        restoreState(restoredState);


        document.getElementById('previous').classList.remove('disabled','enabled');
        document.getElementById('previous').classList.add('disabled');
        document.getElementById('previous').disabled = true;

        document.getElementById('next').classList.remove('disabled','enabled');
        document.getElementById('next').disabled = false;

        //console.log(undoStack.length,redoStack.length);


    }




    saveState_test = !saveState_test;
}

function restoreState(state) {

    clearScene();
    selectedItem_2=null;

    removeresults();

   
    group_data_cube = state.group_data_cube || [];
    group_data_cube_float = state.group_data_cube_float || [];
    //groups_data = state.groups_data || [];
    //spheres = state.spheres || [];
    nomprojet=state.nomprojet;
    nomredacteur=state.nomredacteur;
    nomsociete=state.nomsociete;
    niveau_protection=state.niveau_protection;
    rho=state.rho;
    le=state.le;
    Couleur_scene=state.Couleur_scene;
    couleur_object=state.couleur_object;
    couleur_resultats=state.couleur_resultats;
    Couleurlignes=state.Couleurlignes;
    Rayon=state.Rayon;
    taille_noeuds_s=state.taille_noeuds_s;


    previousState = {
        group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
        group_data_cube_float : JSON.parse(JSON.stringify(group_data_cube_float || [])),
        //groups_data : JSON.parse(JSON.stringify(groups_data || [])),
        //spheres : JSON.parse(JSON.stringify(spheres || [])),
        nomprojet: nomprojet || null,
        nomredacteur: nomredacteur || null,
        nomsociete: nomsociete || null,
        niveau_protection: niveau_protection || null,
        rho: rho || null, // No need for JSON.parse(JSON.stringify()) for primitives
        le: le || null, // No need for JSON.parse(JSON.stringify()) for primitives
        Couleur_scene: Couleur_scene || null,
        couleur_object: couleur_object || null,
        couleur_resultats: couleur_resultats || null,
        Couleurlignes: Couleurlignes || null,
        Rayon: Rayon || null,
        taille_noeuds_s: taille_noeuds_s || null,
    };



    document.getElementById('nom_projet').value=nomprojet;
    document.getElementById('nom_redacteur').value=nomredacteur;
    document.getElementById('nom_societe').value=nomsociete;
    document.getElementById('niveau-protection').value=niveau_protection;
    document.getElementById('resistivite').value=rho.toFixed(2);
    document.getElementById('Couleur_scene').value=Couleur_scene;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene
    document.getElementById('Couleur_object').value=couleur_object;
    document.getElementById('Couleur_lignes').value=Couleurlignes;
    document.getElementById('Couleur_resultats').value=couleur_resultats;
    document.getElementById('taille-noeuds').value=taille_noeuds_s;
    document.getElementById('taille-noeuds-value').textContent=taille_noeuds_s;


        
    // Clear and recreate scene elements
    //clearScene(); // Custom function to remove all elements from the scene
    displayShapes(); // Custom function to add all elements back based on the restored state
}



async function programme_principal() {

    removeresults();

    if (spheres.length===0) {

var message_box = "Absence de noeuds dans le modèle élaboré !";
Swal.fire({
    html: message_box,
    icon: "warning",
    customClass: {
    icon: 'custom-icon'
    }
});

// alert('Absence de structures !');

return


}

if (spheres.length<3) {

var message_box = "Le nombre de noeuds est insuffisant dans le modèle élaboré !";
Swal.fire({
html: message_box,
icon: "warning",
customClass: {
icon: 'custom-icon'
}
});

// alert('Absence de structures !');

return


}



area = 0;

document.getElementById('print-results').disabled = false;
document.getElementById('print-results').classList.remove('disabled');
document.getElementById('print-results').classList.add('enabled');
    

    if (circle) {
        scene.remove(circle);
        circle.geometry.dispose(); // Libérez la mémoire de la géométrie
        circle.material.dispose(); // Libérez la mémoire du matériau
        circle = null; // Supprimez la référence

    }

    if (textMesh) {

        scene.remove(textMesh);
        //textMesh.geometry.dispose(); // Libérez la mémoire de la géométrie
        //textMesh.material.dispose(); // Libérez la mémoire du matériau
        textMesh=null;

    }

    if (points_lines.length>=3) {


    x0=points_lines[0].x;
    y0=points_lines[0].y;
    z0=points_lines[0].z;

    xn=points_lines[points_lines.length-1].x;
    yn=points_lines[points_lines.length-1].y;
    zn=points_lines[points_lines.length-1].z;

    const response = await fetch('/calcul_As_RGE', {
    method: 'POST',
    headers: {
    'Content-Type': 'application/json'
    },
    body: JSON.stringify({points_lines})
    });
 
    // Attend la réponse du serveur
    const result = await response.json();

    area = result.area;
    

    

    Rayon_geometrique=Math.sqrt(area/Math.PI);

    let sumX = 0, sumY = 0, sumZ = 0;
    const n = points_lines.length;

    points_lines.forEach(point => {
        sumX += point.x;
        sumY += point.y;
        sumZ += point.z;
    });

    const centerX = sumX / n;
    const centerY = sumY / n;
    const centerZ = sumZ / n;

    const points_c = [];
    const segments = 100; // Nombre de segments pour approximer le cercle

    for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        const x = centerX + Rayon_geometrique * Math.cos(theta);
        const y = centerY + Rayon_geometrique * Math.sin(theta);
        const z = centerZ;

        if (isNaN(x) || isNaN(y) || isNaN(z)) {
        console.error("Coordonnées invalides.",Rayon_geometrique);
        return; // Exit the function if invalid values are detected
    }
        points_c.push(new THREE.Vector3(x, z, y));
    }



    const geometry = new THREE.BufferGeometry().setFromPoints(points_c);
    const material = new THREE.LineDashedMaterial({
        color: couleur_resultats, // Couleur verte
        dashSize: 0.2,   // Taille des segments visibles
        gapSize: 0.2     // Taille des segments invisibles
    });

    //if (!circle) {

        scene.remove(circle)

        // Créez la ligne (cercle)
        circle = new THREE.Line(geometry, material);
        circle.computeLineDistances(); // Nécessaire pour que le trait discontinu fonctionne
        scene.add(circle);


    //}  else {
    // Mettre à jour la géométrie de l'anneau existant
   ///circle.geometry.dispose(); // Libère l'ancienne géométrie
    //circle.geometry = geometry; // Remplace la géométrie par la nouvelle
    //circle.computeLineDistances(); // Recalcule les distances pour le trait discontinu
    //}

    label='Re: '+Rayon_geometrique.toFixed(2)+' m';

    addResult(centerX-9, centerY,5,label);

    top_view ();

    if (Rayon_geometrique>=le) {
        document.getElementById('results').disabled = false;
        document.getElementById('results').classList.remove('disabled');
        document.getElementById('results').classList.add('enabled');
    } else {
        document.getElementById('results').disabled = true;
        document.getElementById('results').classList.add('disabled');
    }


} 
   

};



function new_file() {

    window.open('RAYON GEOMETRIQUE EQUIVALENT VERSION FINALE 19 08 24 SERVEUR.html', '_blank');
}


let fileHandle;



// Save function
async function save() {
    const data = {
        nomprojet,
        nomredacteur,
        nomsociete,
        rho,
        niveau_protection,
        le,
        group_data_cube,
        group_data_cube_float,
        groups_data,
        spheres,
        itemCounter_sp,
        mission_rg:'rg',
        camera_position,
        Couleur_scene,
        couleur_object,
        couleur_resultats,
        Couleurlignes,
        Rayon,
        taille_noeuds_s,
        camera_position_s
    };

    const jsonData = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonData], { type: 'application/json' });

    try {
        if (!fileHandle) {
            // If no file handle, ask the user to pick a file and save for the first time
            fileHandle = await showSaveFilePicker({
                suggestedName: fileName || 'RG_Calcul_Rayon_Geometrique.json',
                types: [{
                    description: 'JSON Files',
                    accept: { 'application/json': ['.json'] },
                }],
            });

            fileName = fileHandle.name; // Store the new file name if a new file is picked
        }

        // Create a writable stream and write the blob to the file
        const writableStream = await fileHandle.createWritable();
        await writableStream.write(blob);
        await writableStream.close();
        //alert('Fichier enregistré avec succès.');
    } catch (err) {
        if (err.name === 'AbortError') {
            //console.warn('Ouverture du fichier a été abandonnée.');
        } else {
            //console.error('Erreur de lecture du fichier:', err);
        }
    }
}

// Save As function
async function save_as() {
    const data = {
        nomprojet,
        nomredacteur,
        nomsociete,
        rho,
        niveau_protection,
        le,
        group_data_cube,
        group_data_cube_float,
        groups_data,
        spheres,
        itemCounter_sp,
        mission_rg:'rg',
        camera_position,
        Couleur_scene,
        couleur_object,
        couleur_resultats,
        Couleurlignes,
        Rayon,
        taille_noeuds_s,
        camera_position_s
    };

    const jsonData = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonData], { type: 'application/json' });

    if (window.showSaveFilePicker) {
        // Use File System Access API if available
        try {

            const suggestedName = fileName || 'RG_Calcul_Rayon_Geometrique.json'; // Use stored fileName or default
            // Open a file picker to select the file to save
            fileHandle = await showSaveFilePicker({
                suggestedName: suggestedName,
                types: [{
                    description: 'JSON Files',
                    accept: { 'application/json': ['.json'] },
                }],
            });

            fileName = fileHandle.name; // Store the file name
            // Create a writable stream and write the blob to the file
            const writableStream = await fileHandle.createWritable();
            await writableStream.write(blob);
            await writableStream.close();
            
            //alert('Fichier enregistré avec succès.');
        } catch (err) {
            if (err.name === 'AbortError') {
                //console.warn('Ouverture du fichier a été abandonnée.');
            } else {
                //console.error('Erreur de lecture du fichier:', err);
            }
        }
    } else {
        // Fallback for browsers without File System Access API
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'calcul_distance_separation.json';
        a.click();
        URL.revokeObjectURL(url);
    }
}

let fileName;

document.getElementById('openShapesButton').addEventListener('click', async(event) => {

    try {
        // Open file picker and get the file handle
        [fileHandle] = await window.showOpenFilePicker({
            types: [{
                description: 'JSON Files',
                accept: { 'application/json': ['.json'] },
            }],
        });


    fileName = fileHandle.name; // Store the file name

    const file = await fileHandle.getFile(); // Get the file object from the file handle

    const reader = new FileReader();
    reader.onload = function(e) {

    try {
    const data = JSON.parse(e.target.result);

    const prefixeAttendu = 'RG_'

    if (!data.mission_rg || (!file.name.startsWith(prefixeAttendu))) {

        alert('Fichier invalide');

        return


    }

    


    clearScene();

    undoStack = [];
    redoStack = [];
    saveState_test = false;

    //console.log(undoStack.length)


    // Replace the existing arrays with the loaded data
    group_data_cube = data.group_data_cube || [];
    group_data_cube_float = data.group_data_cube_float || [];
    groups_data = data.groups_data || [];
    spheres = data.spheres || [];
    nomprojet=data.nomprojet || null;
    nomredacteur=data.nomredacteur || null;
    nomsociete=data.nomsociete || null;
    niveau_protection=data.niveau_protection|| null;
    rho=data.rho|| null;
    le=data.le|| null;
    camera_position=data.camera_position|| null;
    Couleur_scene=data.Couleur_scene|| null;
    couleur_object=data.couleur_object|| null;
    couleur_resultats=data.couleur_resultats|| null;
    Couleurlignes=data.Couleurlignes|| null;
    Rayon=data.Rayon || null;
    taille_noeuds_s=data.taille_noeuds_s || null;
    camera_position_s=data.camera_position_s || null;

    document.getElementById('nom_projet').value=nomprojet;
    document.getElementById('nom_redacteur').value=nomredacteur;
    document.getElementById('nom_societe').value=nomsociete;
    document.getElementById('niveau-protection').value=niveau_protection;
    document.getElementById('resistivite').value=rho.toFixed(2);
    document.getElementById('Couleur_scene').value=Couleur_scene;
    renderer.setClearColor(Couleur_scene, 1); // Updates the background color of the scene
    document.getElementById('Couleur_object').value=couleur_object;
    document.getElementById('Couleur_lignes').value=Couleurlignes;
    document.getElementById('Couleur_resultats').value=couleur_resultats;
    document.getElementById('camera-position').value=camera_position_s;
    document.getElementById('camera-position-value').textContent=camera_position_s;
    document.getElementById('taille-noeuds').value=taille_noeuds_s;
    document.getElementById('taille-noeuds-value').textContent=taille_noeuds_s;
    camera.position.set(camera_position, camera_position, camera_position);
    camera.lookAt(0, 0, 0);
    controls.update();

    document.getElementById('previous').classList.remove('enabled','disabled');
    document.getElementById('next').classList.remove('enabled','disabled');
    document.getElementById('previous').classList.add('disabled');
    document.getElementById('next').classList.add('disabled');
    document.getElementById('previous').disabled = true;
    document.getElementById('next').disabled = true;

    previousState = {
    group_data_cube : JSON.parse(JSON.stringify(group_data_cube || [])),
    group_data_cube_float : JSON.parse(JSON.stringify(group_data_cube_float || [])),
    //groups_data : JSON.parse(JSON.stringify(groups_data || [])),
    //spheres : JSON.parse(JSON.stringify(spheres || [])),
    nomprojet: nomprojet || null,
    nomredacteur: nomredacteur || null,
    nomsociete: nomsociete || null,
    niveau_protection: niveau_protection || null,
    rho: rho || null, // No need for JSON.parse(JSON.stringify()) for primitives
    le: le || null, // No need for JSON.parse(JSON.stringify()) for primitives
    Couleur_scene: Couleur_scene || null,
    couleur_object: couleur_object || null,
    couleur_resultats: couleur_resultats || null,
    Couleurlignes: Couleurlignes || null,
    Rayon: Rayon || null,
    taille_noeuds_s: taille_noeuds_s || null,

    }


    // Update the display with the new data
    displayShapes();

    
 
    } catch (error) {
        
       alert('Fichier invalide');
       return;

    }

    };

    reader.onerror = function() {
        alert('Erreur de lecture du fichier');
    };




    reader.readAsText(file);

    } catch (error) {


            
    //console.error('Erreur lors de l\'ouverture du fichier:', error);
    //alert('Erreur lors de l\'ouverture du fichier.');
    }
        
});

var shape_creation = false;

function displayShapes() {

    document.getElementById('label-list').innerHTML = '';
    document.getElementById('item-list').innerHTML = '';
    groups_data = [];
    spheres = [];
    shape_creation = !shape_creation;


    for (let o = 0; o <= group_data_cube.length - 1; o++) {
        const index = o;
        const group_name = group_data_cube_float[index]?.group_name;


        if (group_name) {


            structure_spherique_1 (group_data_cube[index].prevPosX, group_data_cube[index].prevPosY, group_data_cube[index].prevPosZ, 0, index);
      
        } 


    }

    //drawLines();

    


    shape_creation = !shape_creation;
}

function clearScene() {

    removeresults();

    for (let o = groups_data.length - 1; o >= 0; o--) {

        const { group, newItem } = groups_data[o];
        scene.remove(group);
        newItem.remove();

    }

    spheres.forEach(sphere => {
        scene.remove(sphere); // Supprime l'élément `line` de la scène
    });

    lines.forEach(line => {
        scene.remove(line); // Supprime l'élément `line` de la scène
    });

    // Clear the arrays
    group_data_cube = [];
    group_data_cube_float = [];
    groups_data = [];
    spheres = [];
    lines =[];
    points_lines=[];
    itemCounter_sp=0;
}





























        
    </script>
</body>
</html>
